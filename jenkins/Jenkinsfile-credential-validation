// Jenkins CI pipeline for validating JFrog Artifactory credentials across multiple ecosystem plugins.
// Runs nightly to ensure credentials are properly configured and functional.
// Notifies Slack with validation results in markdown table format.

node("docker-ubuntu20-xlarge") {
    properties([
        parameters([
            string(
                name: 'SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION',
                defaultValue: 'jfrog-plugins-notifications',
                description: 'Slack channel for credential validation notifications'
            ),
            choice(
                name: 'PLUGIN_TO_VALIDATE',
                choices: ['ALL', 'jenkins-jfrog-plugin', 'bamboo-jfrog-plugin', 'teamcity-jfrog-plugin', 'azure-devops-extension'],
                description: 'Select specific plugin to validate or ALL for all plugins'
            )
        ]),
        pipelineTriggers([
            cron('0 1 * * *')  // Run at 1 AM daily
        ])
    ])
    
    try {
        validationResults = [:]
        buildStatus = 'SUCCESS'
        cliExecutableName = 'jf'
        formattedDate = new Date().format('yyyy-MM-dd HH:mm:ss')
        env.JFROG_CLI_LOG_LEVEL = "ERROR"  // Minimize logging for security
        slackChannelName = params.SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION
        pluginToValidate = params.PLUGIN_TO_VALIDATE
        
        // Define plugin credential mapping
        def pluginsMap = [
            "jenkins-jfrog-plugin": [
                credId: "jenkins-plugin-creds",
                credUrlId: "jenkins-plugin-url",
                active: true,
                displayName: "Jenkins JFrog Plugin"
            ],
            "bamboo-jfrog-plugin": [
                credId: "bamboo-plugin-creds",
                credUrlId: "bamboo-plugin-url",
                active: false,
                displayName: "Bamboo JFrog Plugin"
            ],
            "teamcity-jfrog-plugin": [
                credId: "teamcity-plugin-creds",
                credUrlId: "teamcity-plugin-url",
                active: false,
                displayName: "TeamCity JFrog Plugin"
            ],
            "azure-devops-extension": [
                credId: "azure-devops-plugin-creds",
                credUrlId: "azure-devops-plugin-url",
                active: false,
                displayName: "Azure DevOps Extension"
            ]
        ]
        
        dir('credential-validation-temp') {
            stage('Initial Setup') {
                try {
                    script {
                        installJfrogCli()
                        echo "JFrog CLI installed successfully"
                    }
                } catch (e) {
                    echo "Error during initial setup: ${e}"
                    throw e
                }
            }
            
            script {
                def tasksToRun = createValidationTasks(pluginsMap, pluginToValidate)
                parallel(tasksToRun)
            }
        }
    } catch (e) {
        echo "ERROR: Pipeline failed with exception: ${e}"
        buildStatus = 'FAILURE'
        throw e
    } finally {
        stage('Send Notifications') {
            sendSlackNotification(validationResults, buildStatus, slackChannelName, formattedDate)
        }
    }
}

def sendSlackNotification(Map validationResults, String buildStatus, String channelName, String timestamp) {
    def statusCounts = calculateStatusCounts(validationResults)
    def markdownTable = formatValidationResults(validationResults)
    def notificationConfig = determineNotificationConfig(buildStatus, statusCounts)
    
    def message = buildSlackMessage(notificationConfig, statusCounts, timestamp, markdownTable)
    
    slackSend(
        channel: "#${channelName}",
        message: message,
        color: notificationConfig.color
    )
    
    echo "Final notification message:\n${message}"
}

def calculateStatusCounts(Map validationResults) {
    return [
        success: validationResults.count { k, v -> v.status == 'SUCCESS' },
        failure: validationResults.count { k, v -> v.status == 'FAILURE' },
        skipped: validationResults.count { k, v -> v.status == 'SKIPPED' }
    ]
}

def determineNotificationConfig(String buildStatus, Map statusCounts) {
    if (buildStatus != 'SUCCESS') {
        return [
            icon: '❌',
            title: 'Credential Validation Pipeline Failed',
            color: 'danger',
            mentionChannel: true
        ]
    }
    
    if (statusCounts.failure > 0) {
        return [
            icon: '⚠️',
            title: 'Credential Validation Results',
            color: 'warning',
            mentionChannel: false
        ]
    }
    
    return [
        icon: '✅',
        title: 'Credential Validation Results',
        color: 'good',
        mentionChannel: false
    ]
}

def buildSlackMessage(Map config, Map statusCounts, String timestamp, String markdownTable) {
    def messageBuilder = new StringBuilder()
    
    if (config.mentionChannel) {
        messageBuilder.append('@here ')
    }
    
    messageBuilder.append("*${config.title}* ${config.icon}\n")
    messageBuilder.append("*Date:* ${timestamp}\n")
    
    if (statusCounts.success > 0 || statusCounts.failure > 0 || statusCounts.skipped > 0) {
        messageBuilder.append("*Status:* ")
        def statusParts = []
        
        if (statusCounts.success > 0) {
            statusParts.add("${statusCounts.success} Successful")
        }
        if (statusCounts.failure > 0) {
            statusParts.add("${statusCounts.failure} Failed")
        }
        if (statusCounts.skipped > 0) {
            statusParts.add("${statusCounts.skipped} Skipped")
        }
        
        messageBuilder.append(statusParts.join(', '))
        messageBuilder.append('\n')
    }
    
    messageBuilder.append("<${env.BUILD_URL}|View Build>\n\n")
    messageBuilder.append(markdownTable)
    
    return messageBuilder.toString()
}

def createValidationTasks(Map pluginsMap, String pluginToValidate) {
    def tasks = [:]
    
    pluginsMap.each { pluginName, details ->
        // Filter based on user selection
        if (pluginToValidate == "ALL" || pluginToValidate == pluginName) {
            tasks[pluginName] = {
                validationResults[pluginName] = [
                    status: 'PENDING',
                    message: '',
                    timestamp: '',
                    displayName: details.displayName
                ]
                validatePluginCredentials(pluginName, details)
            }
        }
    }
    
    return tasks
}

def validatePluginCredentials(String pluginName, Map details) {
    def credId = details.credId
    def credUrlId = details.credUrlId
    def isActive = details.active
    def startTime = new Date().format('yyyy-MM-dd HH:mm:ss')
    
    stage("Validate ${details.displayName}") {
        if (!isActive) {
            echo "Skipping ${pluginName} - validation is not active"
            validationResults[pluginName].status = 'SKIPPED'
            validationResults[pluginName].message = 'Validation not active yet'
            validationResults[pluginName].timestamp = startTime
            return
        }
        
        echo "Starting validation for ${pluginName}..."
        def result = testJFrogConnection(credId, credUrlId, pluginName)
        
        validationResults[pluginName].status = result.status
        validationResults[pluginName].message = result.message
        validationResults[pluginName].timestamp = startTime
        
        echo "Validation completed for ${pluginName}: ${result.status}"
    }
}

def testJFrogConnection(String credId, String credUrlId, String pluginName) {
    def tempConfigName = "temp-${pluginName}-${UUID.randomUUID().toString().substring(0, 8)}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        // Check if credentials exist
        def credentialsExist = true
        def credentialsError = ""
        
        try {
            withCredentials([
                usernamePassword(credentialsId: credId, usernameVariable: 'TEMP_USER', passwordVariable: 'TEMP_PASSWORD'),
                string(credentialsId: credUrlId, variable: 'TEMP_URL')
            ]) {
                // Credentials exist, now test connection
                echo "Credentials found for ${pluginName}, testing connection..."
                
                // Configure JFrog CLI with temporary config
                def configResult = sh(
                    script: "jf c add ${tempConfigName} --url=\${TEMP_URL} --user=\${TEMP_USER} --password=\${TEMP_PASSWORD} --overwrite",
                    returnStatus: true
                )
                
                if (configResult != 0) {
                    result.message = "Failed to configure JFrog CLI"
                    return result
                }
                
                // Use the temporary config
                sh "jf c use ${tempConfigName}"
                
                // Test connection with ping
                def pingResult = sh(
                    script: "jf rt ping",
                    returnStatus: true
                )
                
                if (pingResult == 0) {
                    result.status = 'SUCCESS'
                    result.message = 'Connection successful'
                    echo "✅ Connection test passed for ${pluginName}"
                } else {
                    result.message = 'Connection failed - unable to ping JFrog instance'
                    echo "❌ Connection test failed for ${pluginName}"
                }
            }
        } catch (Exception credEx) {
            // Credentials don't exist or other error
            credentialsExist = false
            credentialsError = credEx.message
            
            // Check if it's a missing credentials error
            if (credentialsError.contains("Could not find credentials") || 
                credentialsError.contains("CredentialNotFoundException") ||
                credentialsError.contains("No credentials found")) {
                result.message = "Credentials are not configured yet"
                echo "❌ Credentials not found for ${pluginName}: ${credId} or ${credUrlId}"
            } else {
                result.message = "Error accessing credentials: ${credentialsError}"
                echo "❌ Error accessing credentials for ${pluginName}: ${credentialsError}"
            }
        }
    } catch (Exception e) {
        result.message = "Unexpected error: ${e.message}"
        echo "❌ Unexpected error during validation of ${pluginName}: ${e.message}"
    } finally {
        // Always cleanup the temporary config
        try {
            sh "jf c rm ${tempConfigName} --quiet || true"
        } catch (Exception cleanupEx) {
            echo "Warning: Could not cleanup temp config ${tempConfigName}: ${cleanupEx.message}"
        }
    }
    
    return result
}

def formatValidationResults(Map results) {
    def markdown = new StringBuilder()
    
    // Create markdown table header
    markdown.append("| Plugin | Status | Message | Timestamp |\n")
    markdown.append("|--------|--------|---------|----------|\n")
    
    // Sort results by plugin name for consistent output
    results.sort().each { pluginName, data ->
        def statusEmoji = ''
        switch(data.status) {
            case 'SUCCESS':
                statusEmoji = '✅ SUCCESS'
                break
            case 'FAILURE':
                statusEmoji = '❌ FAILURE'
                break
            case 'SKIPPED':
                statusEmoji = '⏭️ SKIPPED'
                break
            default:
                statusEmoji = '⏳ PENDING'
        }
        
        def displayName = data.displayName ?: pluginName
        def message = data.message ?: 'N/A'
        def timestamp = data.timestamp ?: 'N/A'
        
        markdown.append("| ${displayName} | ${statusEmoji} | ${message} | ${timestamp} |\n")
    }
    
    return markdown.toString()
}

// Install JFrog CLI if not already installed on the system using the curl command
// Check if JFrog CLI is installed by running the jf --version command
def installJfrogCli() {
    def curlStatus = sh(script: 'curl -fL https://install-cli.jfrog.io | sh', returnStatus: true)
    if (curlStatus != 0) {
        error "Failed to download JFrog CLI. Exit code: ${curlStatus}"
    }
    
    def versionStatus = sh(script: 'jf --version', returnStatus: true)
    if (versionStatus != 0) {
        error "Failed to verify JFrog CLI installation. Exit code: ${versionStatus}"
    }
    
    echo "JFrog CLI installed successfully"
}

