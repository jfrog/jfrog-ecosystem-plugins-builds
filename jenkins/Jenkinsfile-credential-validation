// Jenkins CI pipeline for validating JFrog Artifactory credentials across multiple ecosystem plugins.
// Runs nightly to ensure credentials are properly configured and functional.
// Notifies Slack with validation results in markdown table format.

node("docker-ubuntu20-xlarge") {
    properties([
        parameters([
            string(
                name: 'SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION',
                defaultValue: 'jfrog-ecosystem-plugins-notifications',
                description: 'Slack channel for credential validation notifications'
            ),
            choice(
                name: 'PLUGIN_TO_VALIDATE',
                choices: ['ALL', 'jenkins-jfrog-plugin', 'gradle-jfrog-plugin', 'bamboo-jfrog-plugin', 'teamcity-jfrog-plugin', 'azure-devops-extension', 'artifactory-maven-plugin'],
                description: 'Select specific plugin to validate or ALL for all plugins'
            )
        ]),
        pipelineTriggers([
            cron('0 1 * * *')
        ])
    ])
    
    try {
        validationResults = [:]
        buildStatus = 'SUCCESS'
        cliExecutableName = 'jf'
        formattedDate = new Date().format('yyyy-MM-dd HH:mm:ss')
        env.JFROG_CLI_LOG_LEVEL = "ERROR"  // Minimize logging for security
        slackChannelName = params.SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION
        pluginToValidate = params.PLUGIN_TO_VALIDATE
        
        // Debug: Log the actual parameter value being used
        echo "ğŸ“¢ Slack Channel Parameter: '${slackChannelName}'"
        echo "   (Note: To change this, update the parameter in Jenkins UI: Job â†’ Configure â†’ Parameters)"
        
        // ============================================================================
        // PLUGIN REGISTRY - Add your plugins here (Plug & Play)
        // ============================================================================
        // Just add an entry with credFileId, displayName, and validatorType
        // The system will automatically handle the rest!
        //
        // validatorType options:
        //   - "jfrog"   : Uses JFrog CLI
        //   - "nexus"   : Uses Nexus REST API (for Gradle)
        //   - "github"  : Uses GitHub API to trigger/check workflows
        //   - "custom"  : Uses custom validator function (provide customValidator)
        //   - "skip"    : Skip validation (or omit validatorType entirely)
        //
        // If validatorType is not specified or set to "skip", the plugin will be SKIPPED
        // ============================================================================
        
        def pluginsMap = [
            "jenkins-jfrog-plugin": [
                credFileId: "jenkins-jfrog-creds",
                displayName: "Jenkins JFrog Plugin",
                active: true,
                validatorType: "jfrog"
            ],
            "gradle-jfrog-plugin": [
                credFileId: "gradle-plugin-creds-json",
                displayName: "Gradle JFrog Plugin",
                active: true,
                validatorType: "nexus"
            ],
            "bamboo-jfrog-plugin": [
                credFileId: "bamboo-plugin-creds-json",
                displayName: "Bamboo JFrog Plugin",
                active: false,
                validatorType: "jfrog"
            ],
            "teamcity-jfrog-plugin": [
                credFileId: "teamcity-plugin-creds-json",
                displayName: "TeamCity JFrog Plugin",
                active: false,
                validatorType: "jfrog"
            ],
            "azure-devops-extension": [
                credFileId: "azure-devops-plugin-creds-json",
                displayName: "Azure DevOps Extension",
                active: false,
                validatorType: "jfrog"
            ],
            "artifactory-maven-plugin": [
                credFileId: "artifactory-maven-plugin-github-creds",
                displayName: "Artifactory Maven Plugin",
                active: true,
                validatorType: "github"
            ]
            
            // ========================================
            // TO ADD A NEW PLUGIN - Just copy this template:
            // ========================================
            // ,"my-new-plugin": [
            //     credFileId: "my-plugin-creds",
            //     displayName: "My New Plugin",
            //     active: false,
            //     validatorType: "skip"  // Options: "jfrog", "nexus", "github", "custom", "skip"
            //                            // Leave as "skip" or omit validatorType to skip validation
            // ]
        ]
        
        dir('credential-validation-temp') {
            stage('Initial Setup') {
                try {
                    script {
                        installJfrogCli()
                        echo "JFrog CLI installed successfully"
                    }
                } catch (e) {
                    echo "Error during initial setup: ${e}"
                    throw e
                }
            }
            
            script {
                def tasksToRun = createValidationTasks(pluginsMap, pluginToValidate)
                parallel(tasksToRun)
            }
        }
    } catch (e) {
        echo "ERROR: Pipeline failed with exception: ${e}"
        buildStatus = 'FAILURE'
        throw e
    } finally {
        stage('Send Notifications') {
            sendSlackNotification(validationResults, buildStatus, slackChannelName, formattedDate)
        }
    }
}

def sendSlackNotification(Map validationResults, String buildStatus, String channelName, String timestamp) {
    def statusCounts = calculateStatusCounts(validationResults)
    def notificationConfig = determineNotificationConfig(buildStatus, statusCounts)
    
    // Print detailed results to Jenkins console
    def detailedTable = formatValidationResultsForJenkins(validationResults)
    echo "=" * 80
    echo "VALIDATION RESULTS"
    echo "=" * 80
    echo detailedTable
    echo "=" * 80
    
    // Create compact message for Slack
    def slackTable = formatValidationResultsForSlack(validationResults)
    def message = buildSlackMessage(notificationConfig, statusCounts, timestamp, slackTable)
    
    // Try to send Slack notification
    try {
        if (channelName && channelName.trim() != '') {
            slackSend(
                channel: "#${channelName}",
                message: message,
                color: notificationConfig.color
            )
            echo "âœ… Slack notification sent successfully to #${channelName}"
        } else {
            echo "âš ï¸ Slack notification skipped: No channel name configured"
        }
    } catch (Exception slackEx) {
        echo "âš ï¸ Slack notification failed (non-critical): ${slackEx.message}"
        echo "   Results are printed above."
    }
}

def calculateStatusCounts(Map validationResults) {
    return [
        success: validationResults.count { k, v -> v.status == 'SUCCESS' },
        failure: validationResults.count { k, v -> v.status == 'FAILURE' },
        skipped: validationResults.count { k, v -> v.status == 'SKIPPED' }
    ]
}

def determineNotificationConfig(String buildStatus, Map statusCounts) {
    if (buildStatus != 'SUCCESS') {
        return [
            icon: 'âŒ',
            title: 'Credential Validation Pipeline Failed',
            color: 'danger',
            mentionChannel: true
        ]
    }
    
    if (statusCounts.failure > 0) {
        return [
            icon: 'âš ï¸',
            title: 'Credential Validation Results',
            color: 'warning',
            mentionChannel: false
        ]
    }
    
    return [
        icon: 'âœ…',
        title: 'Credential Validation Results',
        color: 'good',
        mentionChannel: false
    ]
}

def buildSlackMessage(Map config, Map statusCounts, String timestamp, String markdownTable) {
    def messageBuilder = new StringBuilder()
    
    if (config.mentionChannel) {
        messageBuilder.append('@here ')
    }
    
    messageBuilder.append("*${config.title}* ${config.icon}\n")
    messageBuilder.append("*Date:* ${timestamp}\n")
    
    if (statusCounts.success > 0 || statusCounts.failure > 0 || statusCounts.skipped > 0) {
        messageBuilder.append("*Status:* ")
        def statusParts = []
        
        if (statusCounts.success > 0) {
            statusParts.add("âœ… ${statusCounts.success} Successful")
        }
        if (statusCounts.failure > 0) {
            statusParts.add("âŒ ${statusCounts.failure} Failed")
        }
        if (statusCounts.skipped > 0) {
            statusParts.add("â­ï¸ ${statusCounts.skipped} Skipped")
        }
        
        messageBuilder.append(statusParts.join(', '))
        messageBuilder.append('\n')
    }
    
    messageBuilder.append("<${env.BUILD_URL}|View Build>\n\n")
    messageBuilder.append(markdownTable)
    
    return messageBuilder.toString()
}

def createValidationTasks(Map pluginsMap, String pluginToValidate) {
    def tasks = [:]
    
    pluginsMap.each { pluginName, details ->
        // Filter based on user selection
        if (pluginToValidate == "ALL" || pluginToValidate == pluginName) {
            tasks[pluginName] = {
                validationResults[pluginName] = [
                    status: 'PENDING',
                    message: '',
                    timestamp: '',
                    displayName: details.displayName
                ]
                validatePluginCredentials(pluginName, details)
            }
        }
    }
    
    return tasks
}

def validatePluginCredentials(String pluginName, Map details) {
    def startTime = new Date().format('yyyy-MM-dd HH:mm:ss')
    
    stage("Validate ${details.displayName}") {
        // Check for skip conditions
        def skipReason = getSkipReason(details)
        if (skipReason) {
            recordSkippedValidation(pluginName, skipReason, startTime)
            return
        }
        
        // Run validation
        echo "Starting validation for ${pluginName}..."
        echo "Using validator type: ${details.validatorType}"
        
        def validator = getValidatorFunction(details.validatorType, details.customValidator)
        def result = validator(details.credFileId, pluginName)
        
        validationResults[pluginName].status = result.status
        validationResults[pluginName].message = result.message
        validationResults[pluginName].timestamp = startTime
        
        echo "Validation completed for ${pluginName}: ${result.status}"
    }
}

def getSkipReason(Map details) {
    if (!details.active) {
        return 'Validation not active yet'
    }
    
    def validatorType = details.validatorType
    if (!validatorType || validatorType.toLowerCase() in ['skip', 'none']) {
        return 'No validator configured yet'
    }
    
    return null
}

def recordSkippedValidation(String pluginName, String reason, String timestamp) {
    echo "Skipping ${pluginName} - ${reason}"
    validationResults[pluginName].status = 'SKIPPED'
    validationResults[pluginName].message = reason
    validationResults[pluginName].timestamp = timestamp
}

/**
 * Returns the appropriate validator function based on validatorType
 * Supports: jfrog, nexus, github, custom
 */
def getValidatorFunction(String validatorType, Closure customValidator = null) {
    def validatorMap = [
        'jfrog': this.&validateJFrogPlugin,
        'artifactory': this.&validateJFrogPlugin,
        'nexus': this.&validateGradlePlugin,
        'gradle': this.&validateGradlePlugin,
        'github': this.&validateGitHubActionsPlugin,
        'github-actions': this.&validateGitHubActionsPlugin
    ]
    
    def type = validatorType.toLowerCase()
    
    if (type == 'custom' && customValidator) {
        return customValidator
    }
    
    def validator = validatorMap[type]
    if (validator) {
        return validator
    }
    
    echo "âš ï¸ Unknown validator type '${validatorType}', falling back to JFrog validator"
    return this.&validateJFrogPlugin
}

// ============================================================================
// PLUGIN-SPECIFIC VALIDATORS
// Each plugin has its own validation strategy
// ============================================================================

/**
 * Validator for JFrog Artifactory plugins (Jenkins, Bamboo, TeamCity, Azure DevOps)
 * Uses JFrog CLI to test connection
 */
def validateJFrogPlugin(String credFileId, String pluginName) {
    echo "ğŸ”§ JFrog Artifactory Validator"
    def tempConfigName = "temp-${pluginName}-${UUID.randomUUID().toString().take(8)}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            echo "Testing JFrog Artifactory connection..."
            def configResult = sh(
                script: "jf c add ${tempConfigName} --url='${creds.url}' --user='${creds.username}' --password='${creds.password}' --overwrite",
                returnStatus: true
            )
            
            if (configResult != 0) {
                result.message = "Failed to configure JFrog CLI"
                echo "âŒ JFrog CLI configuration failed"
                return result
            }
            
            sh "jf c use ${tempConfigName}"
            
            def pingResult = sh(
                script: "jf rt ping",
                returnStatus: true
            )
            
            if (pingResult == 0) {
                result.status = 'SUCCESS'
                result.message = 'Connection successful'
                echo "âœ… JFrog Artifactory connection successful"
            } else {
                result.message = 'Connection failed'
                echo "âŒ JFrog Artifactory ping failed"
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    } finally {
        try {
            sh "jf c rm ${tempConfigName} --quiet || true"
        } catch (Exception cleanupEx) {
            echo "Warning: Could not cleanup temp config"
        }
    }
    
    return result
}

/**
 * Validator for Gradle plugin
 * Uses Nexus REST API to test connection
 */
def validateGradlePlugin(String credFileId, String pluginName) {
    echo "ğŸ”§ Gradle/Nexus Validator"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            echo "Testing Nexus connection via REST API..."
            def pingResult = nxPing(creds.url, creds.username, creds.password)
            
            if (pingResult.ok) {
                result.status = 'SUCCESS'
                result.message = pingResult.message ?: 'Connection successful'
                echo "âœ… Nexus connection successful"
                echo "   ${pingResult.message}"
                if (pingResult.username) {
                    echo "   Authenticated as: ${pingResult.username}"
                }
            } else {
                result.message = pingResult.message ?: 'Connection failed'
                echo "âŒ Nexus connection failed"
                echo "   ${pingResult.message}"
                if (pingResult.status) {
                    echo "   HTTP Status: ${pingResult.status}"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

/**
 * Validator for GitHub Actions plugins
 * Three modes: trigger workflow, check run status, or test API connection
 * 
 * JSON format: { "secrets": { "token": "...", "url": "...", "workflow_run_url": "..." } }
 */
def validateGitHubActionsPlugin(String credFileId, String pluginName) {
    echo "ğŸ”§ GitHub Actions Validator"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = readJSON(text: readFile(file: env.CREDS_FILE))
            
            if (!creds.secrets?.token) {
                result.message = "Invalid JSON: missing token"
                echo "âŒ Missing GitHub token"
                return result
            }
            
            def token = creds.secrets.token
            def workflowUrl = creds.secrets.url
            def workflowRunUrl = creds.secrets.workflow_run_url
            
            if (workflowUrl && workflowRunUrl) {
                result = triggerAndCheckWorkflow(token, workflowUrl, workflowRunUrl)
            } else if (workflowRunUrl) {
                result = checkWorkflowRunStatus(token, workflowRunUrl)
            } else {
                result = testGitHubApiConnection(token)
            }
        }
    } catch (Exception e) {
        result.message = "Error: ${e.message}"
        echo "âŒ GitHub Actions validation error: ${e.message}"
    }
    
    return result
}

def triggerAndCheckWorkflow(String token, String workflowUrl, String workflowRunUrl) {
    echo "Triggering GitHub Action workflow..."
    
    def triggerResult = sh(
        script: """
            curl -X POST -s -w '\\n%{http_code}' \
            -H 'Accept: application/vnd.github.v3+json' \
            -H 'Authorization: token ${token}' \
            '${workflowUrl}' \
            -d '{"ref":"main"}'
        """,
        returnStdout: true
    ).trim()
    
    def statusCode = triggerResult.readLines().last()
    
    if (statusCode != "204") {
        echo "âŒ Failed to trigger GitHub Action"
        return [status: 'FAILURE', message: "Failed to trigger workflow (HTTP ${statusCode})"]
    }
    
    echo "âœ… Workflow triggered successfully"
    sleep(5)  // Wait for run to appear
    
    def runStatusJson = sh(
        script: """
            curl -s -H 'Accept: application/vnd.github.v3+json' \
            -H 'Authorization: token ${token}' \
            '${workflowRunUrl}?per_page=1'
        """,
        returnStdout: true
    ).trim()
    
    def runStatus = readJSON(text: runStatusJson)
    
    if (runStatus.workflow_runs && runStatus.workflow_runs.size() > 0) {
        def run = runStatus.workflow_runs[0]
        echo "Latest run status: ${run.status}"
        echo "Run URL: ${run.html_url}"
        echo "âœ… GitHub Actions validation successful"
        return [status: 'SUCCESS', message: "Workflow triggered. Status: ${run.status}"]
    }
    
    echo "âœ… Workflow triggered but run not yet available"
    return [status: 'SUCCESS', message: "Workflow triggered successfully (204)"]
}

def checkWorkflowRunStatus(String token, String workflowRunUrl) {
    echo "Checking GitHub Actions run status..."
    
    def runJson = sh(
        script: """
            curl -s -H 'Accept: application/vnd.github.v3+json' \
            -H 'Authorization: token ${token}' \
            '${workflowRunUrl}'
        """,
        returnStdout: true
    ).trim()
    
    def run = readJSON(text: runJson)
    
    if (!run.status) {
        echo "âŒ Invalid response from GitHub API"
        return [status: 'FAILURE', message: "Failed to get workflow run status"]
    }
    
    echo "Run status: ${run.status}"
    echo "Conclusion: ${run.conclusion ?: 'in_progress'}"
    echo "Run URL: ${run.html_url}"
    
    if (run.conclusion == "success") {
        echo "âœ… GitHub Actions run successful"
        return [status: 'SUCCESS', message: "Workflow run succeeded"]
    }
    
    if (run.status == "completed" && run.conclusion == "failure") {
        echo "âŒ GitHub Actions run failed"
        return [status: 'FAILURE', message: "Workflow run failed"]
    }
    
    echo "âœ… GitHub Actions accessible, run status: ${run.status}"
    return [status: 'SUCCESS', message: "Workflow status: ${run.status}, conclusion: ${run.conclusion ?: 'pending'}"]
}

def testGitHubApiConnection(String token) {
    echo "Testing GitHub API connection..."
    
    def userJson = sh(
        script: """
            curl -s -w '\\n%{http_code}' \
            -H 'Accept: application/vnd.github.v3+json' \
            -H 'Authorization: token ${token}' \
            'https://api.github.com/user'
        """,
        returnStdout: true
    ).trim()
    
    def statusCode = userJson.readLines().last()
    
    if (statusCode == "200") {
        def user = readJSON(text: userJson.readLines()[0..-2].join('\n'))
        echo "âœ… GitHub API connection successful"
        echo "   Authenticated as: ${user.login}"
        return [status: 'SUCCESS', message: "GitHub API connected successfully"]
    }
    
    echo "âŒ GitHub API authentication failed"
    return [status: 'FAILURE', message: "GitHub API authentication failed (HTTP ${statusCode})"]
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Parses and validates credentials JSON file
 * Returns: [ok: boolean, username: string, password: string, url: string, message: string]
 */
def parseCredentialsFile(String filePath, String pluginName) {
    try {
        def creds = readJSON(text: readFile(file: filePath))
        
        if (!creds.secrets) {
            echo "âŒ Invalid JSON: missing 'secrets' key"
            return [ok: false, message: "Invalid JSON: missing 'secrets' key"]
        }
        
        def secrets = creds.secrets
        def missingFields = []
        
        if (!secrets.username) missingFields.add('username')
        if (!secrets.password) missingFields.add('password')
        if (!secrets.url) missingFields.add('url')
        
        if (missingFields) {
            echo "âŒ Missing required fields: ${missingFields.join(', ')}"
            return [ok: false, message: "Missing required fields: ${missingFields.join(', ')}"]
        }
        
        echo "âœ… Credentials parsed successfully"
        return [ok: true, username: secrets.username, password: secrets.password, url: secrets.url]
    } catch (Exception e) {
        echo "âŒ Failed to parse credentials: ${e.message}"
        return [ok: false, message: "Failed to parse JSON: ${e.message}"]
    }
}

/**
 * Handles credential-related errors with helpful troubleshooting info
 */
def handleCredentialError(Exception e, String credFileId, String pluginName) {
    def errorMsg = e.message
    
    echo "âŒ Credential error:"
    echo "   Message: ${errorMsg}"
    echo "   Credential ID: '${credFileId}'"
    
    def isCredentialNotFound = errorMsg?.toLowerCase()?.contains("not found") || 
                               errorMsg?.contains("CredentialNotFoundException")
    
    if (isCredentialNotFound) {
        echo "   Hint: Create secret file credential with ID '${credFileId}'"
        return "Credentials not configured yet"
    }
    
    return "Error: ${errorMsg?.take(50) ?: 'Unknown error'}"
}

def formatValidationResultsForJenkins(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "Plugin", "Status", "Message", "Timestamp"))
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "-" * 30, "-" * 10, "-" * 40, "-" * 19))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)
        def message = data.message ?: 'N/A'
        def timestamp = data.timestamp ?: 'N/A'

        table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
            displayName, status, message, timestamp))
    }

    table.append("```")
    return table.toString()
}

def formatValidationResultsForSlack(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s\n", "Plugin", "Status"))
    table.append(String.format("%-30s | %-10s\n", "-" * 30, "-" * 10))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)

        table.append(String.format("%-30s | %-10s\n", displayName, status))
    }

    table.append("```")
    return table.toString()
}

def getStatusEmoji(String status) {
    switch(status) {
        case 'SUCCESS': return 'âœ…'
        case 'FAILURE': return 'âŒ'
        case 'SKIPPED': return 'â­ï¸'
        default: return status ?: 'N/A'
    }
}

/**
 * Installs JFrog CLI using official installer script
 */
def installJfrogCli() {
    def downloadStatus = sh(
        script: 'curl -fL https://install-cli.jfrog.io | sh',
        returnStatus: true
    )
    
    if (downloadStatus != 0) {
        error "Failed to download JFrog CLI (exit code: ${downloadStatus})"
    }
    
    def verifyStatus = sh(script: 'jf --version', returnStatus: true)
    
    if (verifyStatus != 0) {
        error "Failed to verify JFrog CLI installation (exit code: ${verifyStatus})"
    }
    
    echo "âœ… JFrog CLI installed successfully"
}

/**
 * Tests Nexus Repository connection using /service/local/status endpoint
 * Returns: [ok: boolean, message: string, username: string, status: int]
 * Uses shell commands to avoid Jenkins sandbox restrictions
 */
def nxPing(String nexusUrl, String username, String password) {
    try {
        def endpoint = "${nexusUrl}/service/local/status"
        
        // Use HEAD request (-I) which is lighter and sufficient for authentication check
        def response = sh(
            script: """
                curl -s -I -w '\\n%{http_code}' \
                --user '${username}:${password}' \
                -H 'Accept: application/json' \
                --connect-timeout 5 \
                --max-time 10 \
                '${endpoint}' 2>&1
            """,
            returnStdout: true
        ).trim()
        
        def lines = response.readLines()
        def statusCode = lines.last() as Integer
        
        // Success - credentials are valid
        if (statusCode == 200 || statusCode == 204) {
            echo "âœ… Nexus Repository connection successful"
            return [ok: true, message: "Credentials valid (${statusCode} OK)", username: username, status: statusCode]
        }
        
        // Authentication failed
        if (statusCode == 401) {
            return [ok: false, message: "Unauthorized (401) â€” Invalid username/password", status: 401]
        }
        
        // Permission denied
        if (statusCode == 403) {
            return [ok: false, message: "Forbidden (403) â€” Valid credentials but insufficient permissions", status: 403]
        }
        
        // Endpoint not supported or other error
        return [ok: false, message: "Endpoint not supported (${statusCode})", status: statusCode]

    } catch (Exception e) {
        return [ok: false, message: "Connection error: ${e.message}", status: -1]
    }
}
