// Jenkins CI pipeline for validating JFrog Artifactory credentials across multiple ecosystem plugins.
// Runs nightly to ensure credentials are properly configured and functional.
// Notifies Slack with validation results in markdown table format.

node("docker-ubuntu20-xlarge") {
    properties([
        parameters([
            string(
                name: 'SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION',
                defaultValue: 'jfrog-ecosystem-plugins-notifications',
                description: 'Slack channel for credential validation notifications'
            ),
            choice(
                name: 'PLUGIN_TO_VALIDATE',
                choices: ['ALL', 'jenkins-jfrog-plugin', 'gradle-jfrog-plugin', 'bamboo-jfrog-plugin', 'teamcity-jfrog-plugin', 'azure-devops-extension', 'artifactory-maven-plugin'],
                description: 'Select specific plugin to validate or ALL for all plugins'
            )
        ]),
        pipelineTriggers([
            cron('0 1 * * *')
        ])
    ])
    
    try {
        validationResults = [:]
        buildStatus = 'SUCCESS'
        formattedDate = new Date().format('yyyy-MM-dd HH:mm:ss')
        env.JFROG_CLI_LOG_LEVEL = "ERROR"  // Minimize logging for security
        slackChannelName = params.SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION
        pluginToValidate = params.PLUGIN_TO_VALIDATE
        
        // Debug: Log the actual parameter value being used
        echo "üì¢ Slack Channel Parameter: '${slackChannelName}'"
        echo "   (Note: To change this, update the parameter in Jenkins UI: Job ‚Üí Configure ‚Üí Parameters)"
        
        // ============================================================================
        // PLUGIN REGISTRY - Add your plugins here (Plug & Play)
        // ============================================================================
        // Just add an entry with credFileId, displayName, and validatorType
        // The system will automatically handle the rest!
        //
        // validatorType options:
        //   - "jfrog"   : Uses JFrog CLI
        //   - "nexus"   : Uses Nexus REST API (for Gradle)
        //   - "github"  : Uses GitHub API to trigger/check workflows
        //   - "teamcity": Uses TeamCity REST API
        //   - "azure-devops": Uses Azure DevOps Marketplace API
        //   - "custom"  : Uses custom validator function (provide customValidator)
        //   - "skip"    : Skip validation (or omit validatorType entirely)
        //
        // If validatorType is not specified or set to "skip", the plugin will be SKIPPED
        // ============================================================================
        
        def pluginsMap = [
            "jenkins-jfrog-plugin": [
                credFileId: "jenkins-jfrog-creds",
                displayName: "Jenkins JFrog Plugin",
                active: true,
                validatorType: "jfrog"
            ],
            "gradle-jfrog-plugin": [
                credFileId: "gradle-plugin-creds-json",
                displayName: "Gradle JFrog Plugin",
                active: true,
                validatorType: "nexus"
            ],
            "bamboo-jfrog-plugin": [
                credFileId: "bamboo-plugin-creds-json",
                displayName: "Bamboo JFrog Plugin",
                active: false,
                validatorType: "jfrog"
            ],
            "teamcity-jfrog-plugin": [
                credFileId: "teamcity-plugin-creds-json",
                displayName: "TeamCity JFrog Plugin",
                active: true,
                validatorType: "teamcity"
            ],
            "azure-devops-extension": [
                credFileId: "azure-devops-plugin-creds-json",
                displayName: "Azure DevOps Extension",
                active: true,
                validatorType: "azure-devops"
            ],
            "artifactory-maven-plugin": [
                credFileId: "artifactory-maven-plugin-github-creds",
                displayName: "Artifactory Maven Plugin",
                active: true,
                validatorType: "github",
                githubBranch: "master"
            ]
            
            // ========================================
            // TO ADD A NEW PLUGIN - Just copy this template:
            // ========================================
            // ,"my-new-plugin": [
            //     credFileId: "my-plugin-creds",
            //     displayName: "My New Plugin",
            //     active: false,
            //     validatorType: "skip"  // Options: "jfrog", "nexus", "github", "custom", "skip"
            //                            // Leave as "skip" or omit validatorType to skip validation
            // ]
        ]
        
        dir('credential-validation-temp') {
            stage('Initial Setup') {
                try {
                    script {
                        installJfrogCli()
                        echo "JFrog CLI installed successfully"
                        
                        // Install all prerequisites upfront to avoid lock conflicts
                        // All apt-get operations happen here sequentially
                        installPrerequisites(pluginsMap, pluginToValidate)
                    }
                } catch (e) {
                    echo "Error during initial setup: ${e}"
                    throw e
                }
            }
            
            script {
                // All validations can now run in parallel since prerequisites are installed
                def tasksToRun = createValidationTasks(pluginsMap, pluginToValidate)
                parallel(tasksToRun)
            }
        }
    } catch (e) {
        echo "ERROR: Pipeline failed with exception: ${e}"
        buildStatus = 'FAILURE'
        throw e
    } finally {
        stage('Send Notifications') {
            sendSlackNotification(validationResults, buildStatus, slackChannelName, formattedDate)
        }
    }
}

def sendSlackNotification(Map validationResults, String buildStatus, String channelName, String timestamp) {
    def statusCounts = calculateStatusCounts(validationResults)
    def notificationConfig = determineNotificationConfig(buildStatus, statusCounts)
    
    // Print detailed results to Jenkins console
    def detailedTable = formatValidationResultsForJenkins(validationResults)
    echo "=" * 80
    echo "VALIDATION RESULTS"
    echo "=" * 80
    echo detailedTable
    echo "=" * 80
    
    // Create compact message for Slack
    def slackTable = formatValidationResultsForSlack(validationResults)
    def message = buildSlackMessage(notificationConfig, statusCounts, timestamp, slackTable)
    
    // Try to send Slack notification
    try {
        if (channelName && channelName.trim() != '') {
            slackSend(
                channel: "#${channelName}",
                message: message,
                color: notificationConfig.color
            )
            echo "SUCCESS: Slack notification sent to #${channelName}"
        } else {
            echo "WARNING: Slack notification skipped: No channel name configured"
        }
    } catch (Exception slackEx) {
        echo "WARNING: Slack notification failed (non-critical): ${slackEx.message}"
        echo "   Results are printed above."
    }
}

def calculateStatusCounts(Map validationResults) {
    return [
        success: validationResults.count { k, v -> v.status == 'SUCCESS' },
        failure: validationResults.count { k, v -> v.status == 'FAILURE' },
        skipped: validationResults.count { k, v -> v.status == 'SKIPPED' }
    ]
}

def determineNotificationConfig(String buildStatus, Map statusCounts) {
    if (buildStatus != 'SUCCESS') {
        return [
            icon: '‚ùå',
            title: 'Credential Validation Pipeline Failed',
            color: 'danger',
            mentionChannel: true
        ]
    }
    
    if (statusCounts.failure > 0) {
        return [
            icon: '‚ö†Ô∏è',
            title: 'Credential Validation Results',
            color: 'warning',
            mentionChannel: false
        ]
    }
    
    return [
        icon: '‚úÖ',
        title: 'Credential Validation Results',
        color: 'good',
        mentionChannel: false
    ]
}

def buildSlackMessage(Map config, Map statusCounts, String timestamp, String markdownTable) {
    def messageBuilder = new StringBuilder()
    
    if (config.mentionChannel) {
        messageBuilder.append('@here ')
    }
    
    messageBuilder.append("*${config.title}* ${config.icon}\n")
    messageBuilder.append("*Date:* ${timestamp}\n")
    
    if (statusCounts.success > 0 || statusCounts.failure > 0 || statusCounts.skipped > 0) {
        messageBuilder.append("*Status:* ")
        def statusParts = []
        
        if (statusCounts.success > 0) {
            statusParts.add("‚úÖ ${statusCounts.success} Successful")
        }
        if (statusCounts.failure > 0) {
            statusParts.add("‚ùå ${statusCounts.failure} Failed")
        }
        if (statusCounts.skipped > 0) {
            statusParts.add("‚è≠Ô∏è ${statusCounts.skipped} Skipped")
        }
        
        messageBuilder.append(statusParts.join(', '))
        messageBuilder.append('\n')
    }
    
    messageBuilder.append("<${env.BUILD_URL}|View Build>\n\n")
    messageBuilder.append(markdownTable)
    
    return messageBuilder.toString()
}

def createValidationTasks(Map pluginsMap, String pluginToValidate) {
    def tasks = [:]
    
    pluginsMap.each { pluginName, details ->
        // Filter based on user selection
        if (pluginToValidate == "ALL" || pluginToValidate == pluginName) {
            tasks[pluginName] = {
                validationResults[pluginName] = [
                    status: 'PENDING',
                    message: '',
                    timestamp: '',
                    displayName: details.displayName
                ]
                validatePluginCredentials(pluginName, details)
            }
        }
    }
    
    return tasks
}

def validatePluginCredentials(String pluginName, Map details) {
    def startTime = new Date().format('yyyy-MM-dd HH:mm:ss')
    
    stage("Validate ${details.displayName}") {
        // Use catchError to mark stage as failed without stopping other parallel validations
        catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
            // Check for skip conditions
            def skipReason = getSkipReason(details)
            if (skipReason) {
                recordSkippedValidation(pluginName, skipReason, startTime)
                return
            }
            
            // Run validation
            echo "Starting validation for ${pluginName}..."
            echo "Using validator type: ${details.validatorType}"
            
            def validator = getValidatorFunction(details.validatorType, details.customValidator)
            def result = validator(details.credFileId, pluginName, details)
            
            validationResults[pluginName].status = result.status
            validationResults[pluginName].message = result.message
            validationResults[pluginName].timestamp = startTime
            
            echo "Validation completed for ${pluginName}: ${result.status}"
            
            // Fail the stage if validation failed
            // catchError will catch this and mark the stage as failed
            if (result.status == 'FAILURE') {
                error("Validation failed for ${details.displayName}: ${result.message}")
            }
        }
    }
}

def getSkipReason(Map details) {
    if (!details.active) {
        return 'Validation not active yet'
    }
    
    def validatorType = details.validatorType
    if (!validatorType || validatorType.toLowerCase() in ['skip', 'none']) {
        return 'No validator configured yet'
    }
    
    return null
}

def recordSkippedValidation(String pluginName, String reason, String timestamp) {
    echo "Skipping ${pluginName} - ${reason}"
    validationResults[pluginName].status = 'SKIPPED'
    validationResults[pluginName].message = reason
    validationResults[pluginName].timestamp = timestamp
}

/**
 * Returns the appropriate validator function based on validatorType
 * Supports: jfrog, nexus, github, azure-devops, teamcity, custom
 */
def getValidatorFunction(String validatorType, Closure customValidator = null) {
    def validatorMap = [
        'jfrog': this.&validateJFrogPlugin,
        'artifactory': this.&validateJFrogPlugin,
        'nexus': this.&validateGradlePlugin,
        'gradle': this.&validateGradlePlugin,
        'github': this.&validateGitHubActionsPlugin,
        'github-actions': this.&validateGitHubActionsPlugin,
        'azure-devops': this.&checkAdoMarketplaceAuth,
        'teamcity': this.&validateTeamCityPlugin
    ]
    
    def type = validatorType.toLowerCase()
    
    if (type == 'custom' && customValidator) {
        return customValidator
    }
    
    def validator = validatorMap[type]
    if (validator) {
        return validator
    }
    
    echo "WARNING: Unknown validator type '${validatorType}', falling back to JFrog validator"
    return this.&validateJFrogPlugin
}

// ============================================================================
// PLUGIN-SPECIFIC VALIDATORS
// Each plugin has its own validation strategy
// ============================================================================

/**
 * Validator for JFrog Artifactory plugins (Jenkins, Bamboo, TeamCity, Azure DevOps)
 * Uses JFrog CLI to test connection
 */
def validateJFrogPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "JFrog Artifactory Validator"
    def tempConfigName = "temp-${pluginName}-${UUID.randomUUID().toString().take(8)}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.url, var: 'SECRET_URL'],
                [password: creds.username, var: 'SECRET_USER'],
                [password: creds.password, var: 'SECRET_PASS']
            ]]) {
                echo "Testing JFrog Artifactory connection..."
                def configResult = 0
                withEnv([
                    "JFROG_URL=${creds.url}",
                    "JFROG_USER=${creds.username}",
                    "JFROG_PASSWORD=${creds.password}"
                ]) {
                    configResult = sh(
                        script: '''jf c add ''' + tempConfigName + ''' --url="${JFROG_URL}" --user="${JFROG_USER}" --password="${JFROG_PASSWORD}" --overwrite''',
                        returnStatus: true
                    )
                }
                
                if (configResult != 0) {
                    result.message = "Failed to configure JFrog CLI"
                    echo "ERROR: JFrog CLI configuration failed"
                    return result
                }
                
                sh "jf c use ${tempConfigName}"
                
                def pingResult = sh(
                    script: "jf rt ping",
                    returnStatus: true
                )
                
                if (pingResult == 0) {
                    result.status = 'SUCCESS'
                    result.message = 'Connection successful'
                    echo "SUCCESS: JFrog Artifactory connection successful"
                } else {
                    result.message = 'Connection failed'
                    echo "ERROR: JFrog Artifactory ping failed"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    } finally {
        try {
            sh "jf c rm ${tempConfigName} --quiet || true"
        } catch (Exception cleanupEx) {
            echo "Warning: Could not cleanup temp config"
        }
    }
    
    return result
}

/**
 * Validator for Gradle plugin
 * Uses Nexus REST API to test connection
 */
def validateGradlePlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "Gradle/Nexus Validator"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.url, var: 'SECRET_URL'],
                [password: creds.username, var: 'SECRET_USER'],
                [password: creds.password, var: 'SECRET_PASS']
            ]]) {
                echo "Testing Nexus connection via REST API..."
                def pingResult = nxPing(creds.url, creds.username, creds.password)
                
                if (pingResult.ok) {
                    result.status = 'SUCCESS'
                    result.message = pingResult.message ?: 'Connection successful'
                    echo "SUCCESS: Nexus connection successful"
                    echo "   ${pingResult.message}"
                    if (pingResult.username) {
                        echo "   Authenticated as: ${pingResult.username}"
                    }
                } else {
                    result.message = pingResult.message ?: 'Connection failed'
                    echo "ERROR: Nexus connection failed"
                    echo "   ${pingResult.message}"
                    if (pingResult.status) {
                        echo "   HTTP Status: ${pingResult.status}"
                    }
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

/**
 * Validator for TeamCity plugin
 * Uses JetBrains Plugin Repository REST API to validate token credentials
 * Validates that the token can authenticate and access vendor information
 */
def validateTeamCityPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "TeamCity Validator (JetBrains Plugin Repository)"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseTeamCityCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            // Mask both the token variable and the environment variable used by the script
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.token, var: 'SECRET_TOKEN'],
                [password: creds.token, var: 'JETBRAINS_PLUGIN_TOKEN'],
                [password: creds.url ?: '', var: 'SECRET_URL']
            ]]) {
                echo "Testing JetBrains Plugin Repository connection..."
                def validationResult = validateJetBrainsPluginRepository(creds.token, creds.url)
                
                if (validationResult.ok) {
                    result.status = 'SUCCESS'
                    result.message = validationResult.message ?: 'Connection successful'
                    echo "SUCCESS: JetBrains Plugin Repository connection successful"
                    echo "   ${validationResult.message}"
                    if (validationResult.vendorName) {
                        echo "   Vendor: ${validationResult.vendorName}"
                    }
                    if (validationResult.vendorUrl) {
                        echo "   Vendor URL: ${validationResult.vendorUrl}"
                    }
                } else {
                    result.message = validationResult.message ?: 'Connection failed'
                    echo "ERROR: JetBrains Plugin Repository connection failed"
                    echo "   ${validationResult.message}"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

/**
 * Validator for GitHub Actions plugins
 * Three modes: trigger workflow, check run status, or test API connection
 * 
 * JSON format: { "secrets": { "token": "...", "url": "...", "workflow_run_url": "..." } }
 */
def validateGitHubActionsPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "GitHub Actions Validator"
    echo "   Plugin: ${pluginName}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = readJSON(text: readFile(file: env.CREDS_FILE))
            
            if (!creds.secrets?.token) {
                result.message = "Invalid JSON: missing token"
                echo "ERROR: Missing GitHub token in credential file"
                return result
            }
            
            def token = creds.secrets.token
            def workflowUrl = creds.secrets.url
            def workflowRunUrl = creds.secrets.workflow_run_url
            // Use branch from plugin config, then credential file, then default to 'main'
            def targetBranch = pluginDetails.githubBranch ?: creds.secrets.branch ?: 'main'
            
            echo "   Credential configuration:"
            echo "   - Token: ${token ? 'Present' : 'Missing'}"
            echo "   - Workflow URL: ${workflowUrl ? 'Present' : 'Missing'}"
            echo "   - Run URL: ${workflowRunUrl ? 'Present' : 'Missing'}"
            echo "   - Target branch: ${targetBranch}"
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[password: token, var: 'SECRET']]]) {
                if (workflowUrl && workflowRunUrl) {
                    echo "   Mode: Trigger and check workflow"
                    result = triggerAndCheckWorkflow(token, workflowUrl, workflowRunUrl, targetBranch)
                } else if (workflowRunUrl) {
                    echo "   Mode: Check workflow run status"
                    result = checkWorkflowRunStatus(token, workflowRunUrl)
                } else {
                    echo "   Mode: Test GitHub API connection only"
                    result = testGitHubApiConnection(token)
                }
            }
        }
    } catch (Exception e) {
        result.message = "Error: ${e.message}"
        echo "ERROR: GitHub Actions validation error: ${e.message}"
        e.printStackTrace()
    }
    
    return result
}

def triggerAndCheckWorkflow(String token, String workflowUrl, String workflowRunUrl, String targetBranch = 'main') {
    echo "Triggering GitHub Actions workflow..."
    echo "   Workflow URL: ${workflowUrl}"
    echo "   Target branch: ${targetBranch}"
    
    def triggerResult = ''
    withEnv([
        "GITHUB_TOKEN=${token}",
        "WORKFLOW_URL=${workflowUrl}",
        "TARGET_BRANCH=${targetBranch}"
    ]) {
        triggerResult = sh(
            script: '''
                curl -X POST -s -w '\\n%{http_code}' \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                "${WORKFLOW_URL}" \
                -d "{\\"ref\\":\\"${TARGET_BRANCH}\\"}" 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def lines = triggerResult.readLines()
    def statusCode = lines.last()
    def responseBody = lines.size() > 1 ? lines[0..-2].join('\n') : ''
    
    echo "   Response: HTTP ${statusCode}"
    if (responseBody && responseBody.trim()) {
        echo "   Response body: ${responseBody.take(300)}"
    }
    
    if (statusCode != "204") {
        echo "ERROR: Failed to trigger GitHub Actions workflow"
        return [status: 'FAILURE', message: "Failed to trigger workflow (HTTP ${statusCode})"]
    }
    
    echo "SUCCESS: Workflow triggered successfully (HTTP 204)"
    echo "   Waiting for workflow run to complete..."
    
    // Poll for workflow completion
    def maxAttempts = 60  // 5 minutes total (60 * 5 seconds)
    def attempt = 0
    def run = null
    
    while (attempt < maxAttempts) {
        sleep(5)
        attempt++
        
        def runStatusJson = ''
        withEnv([
            "GITHUB_TOKEN=${token}",
            "WORKFLOW_RUN_URL=${workflowRunUrl}"
        ]) {
            runStatusJson = sh(
                script: '''
                    curl -s -H 'Accept: application/vnd.github.v3+json' \
                    -H "Authorization: token ${GITHUB_TOKEN}" \
                    "${WORKFLOW_RUN_URL}?per_page=1"
                ''',
                returnStdout: true
            ).trim()
        }
        
        def runStatus = readJSON(text: runStatusJson)
        
        if (runStatus.workflow_runs && runStatus.workflow_runs.size() > 0) {
            run = runStatus.workflow_runs[0]
            
            echo "   Polling attempt ${attempt}/${maxAttempts}:"
            echo "   - Status: ${run.status}"
            echo "   - Conclusion: ${run.conclusion ?: 'pending'}"
            echo "   - Run ID: ${run.id}"
            echo "   - URL: ${run.html_url}"
            
            // Check if workflow has completed
            if (run.status == "completed") {
                echo "   Workflow completed!"
                
                if (run.conclusion == "success") {
                    echo "SUCCESS: GitHub Actions workflow completed successfully"
                    return [status: 'SUCCESS', message: "Workflow completed successfully"]
                } else if (run.conclusion == "failure") {
                    echo "ERROR: GitHub Actions workflow failed"
                    return [status: 'FAILURE', message: "Workflow failed with conclusion: ${run.conclusion}"]
                } else if (run.conclusion == "cancelled") {
                    echo "WARNING: GitHub Actions workflow was cancelled"
                    return [status: 'FAILURE', message: "Workflow cancelled"]
                } else {
                    echo "WARNING: GitHub Actions workflow completed with unexpected conclusion: ${run.conclusion}"
                    return [status: 'FAILURE', message: "Workflow completed with conclusion: ${run.conclusion}"]
                }
            }
            
            // Still in progress, continue polling
        } else {
            echo "   Polling attempt ${attempt}/${maxAttempts}: Workflow run not yet visible"
        }
    }
    
    // Timeout reached
    echo "ERROR: Timeout waiting for workflow to complete (waited ${maxAttempts * 5} seconds)"
    if (run) {
        echo "   Last known status: ${run.status}, conclusion: ${run.conclusion ?: 'pending'}"
        echo "   URL: ${run.html_url}"
    }
    return [status: 'FAILURE', message: "Timeout waiting for workflow completion"]
}

def checkWorkflowRunStatus(String token, String workflowRunUrl) {
    echo "Checking GitHub Actions workflow run status..."
    echo "   Run URL: ${workflowRunUrl}"
    
    def runJson = ''
    withEnv([
        "GITHUB_TOKEN=${token}",
        "WORKFLOW_RUN_URL=${workflowRunUrl}"
    ]) {
        runJson = sh(
            script: '''
                curl -s -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                "${WORKFLOW_RUN_URL}" 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def run = readJSON(text: runJson)
    
    if (!run.status) {
        echo "ERROR: Invalid response from GitHub API"
        echo "   Response may indicate an error or invalid run URL"
        return [status: 'FAILURE', message: "Failed to get workflow run status"]
    }
    
    echo "   Workflow run details:"
    echo "   - Status: ${run.status}"
    echo "   - Conclusion: ${run.conclusion ?: 'in_progress'}"
    echo "   - Run ID: ${run.id ?: 'N/A'}"
    echo "   - URL: ${run.html_url ?: 'N/A'}"
    
    if (run.conclusion == "success") {
        echo "SUCCESS: GitHub Actions workflow run successful"
        return [status: 'SUCCESS', message: "Workflow run succeeded"]
    }
    
    if (run.status == "completed" && run.conclusion == "failure") {
        echo "ERROR: GitHub Actions workflow run failed"
        return [status: 'FAILURE', message: "Workflow run failed"]
    }
    
    echo "SUCCESS: GitHub Actions accessible, workflow is ${run.status}"
    return [status: 'SUCCESS', message: "Workflow status: ${run.status}, conclusion: ${run.conclusion ?: 'pending'}"]
}

def testGitHubApiConnection(String token) {
    echo "Testing GitHub API connection..."
    echo "   Endpoint: https://api.github.com/user"
    
    def userJson = ''
    withEnv(["GITHUB_TOKEN=${token}"]) {
        userJson = sh(
            script: '''
                curl -s -w '\\n%{http_code}' \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                'https://api.github.com/user' 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def lines = userJson.readLines()
    def statusCode = lines.last()
    
    echo "   Response: HTTP ${statusCode}"
    
    if (statusCode == "200") {
        def user = readJSON(text: lines[0..-2].join('\n'))
        echo "SUCCESS: GitHub API connection successful"
        echo "   - Authenticated as: ${user.login}"
        echo "   - Account type: ${user.type ?: 'N/A'}"
        return [status: 'SUCCESS', message: "GitHub API connected as ${user.login}"]
    }
    
    echo "ERROR: GitHub API authentication failed"
    if (statusCode == "401") {
        echo "   Token is invalid or expired"
    }
    return [status: 'FAILURE', message: "GitHub API authentication failed (HTTP ${statusCode})"]
}

/**
 * Validator for Azure DevOps Extension Marketplace
 * Uses tfx CLI to validate Personal Access Token (PAT) for Azure DevOps Marketplace
 * 
 * JSON format: { "secrets": { "token": "...", "publisherId": "...", "extensionId": "..." } }
 */
def checkAdoMarketplaceAuth(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "üîß Azure DevOps Marketplace Validator"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = readJSON(text: readFile(file: env.CREDS_FILE))
            
            if (!creds.secrets?.token) {
                result.message = "Invalid JSON: missing token"
                echo "‚ùå Missing Azure DevOps Personal Access Token"
                return result
            }
            
            def token = creds.secrets.token
            def publisherId = creds.secrets.publisherId
            def extensionId = creds.secrets.extensionId
            
            if (!publisherId) {
                result.message = "Invalid JSON: missing publisherId"
                echo "‚ùå Missing publisherId"
                return result
            }
            
            if (!extensionId) {
                result.message = "Invalid JSON: missing extensionId"
                echo "‚ùå Missing extensionId"
                return result
            }
            
            echo "Testing Azure DevOps Marketplace authentication..."
            
            // Install tfx-cli if not already available (only for Azure DevOps validation)
            try {
                installTfxCli()
            } catch (Exception installEx) {
                result.message = "Failed to install tfx-cli: ${installEx.message}"
                echo "‚ùå Azure DevOps Marketplace validation failed: Could not install tfx-cli"
                echo "   Error: ${installEx.message}"
                return result
            }
            
            // Use withEnv to securely pass token as environment variable
            // Wrap with password masking to prevent credentials from appearing in console logs
            def tfxResult = ''
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[password: token, var: 'AZURE_DEVOPS_TOKEN']]]) {
                withEnv([
                    "AZURE_DEVOPS_TOKEN=${token}",
                    "PUBLISHER_ID=${publisherId}",
                    "EXTENSION_ID=${extensionId}"
                ]) {
                    // Run tfx and capture both output and exit code
                    // Use set +x to prevent command echoing (which could expose credentials)
                    tfxResult = sh(
                        script: '''
                            set +x
                            OUTPUT=$(tfx extension show \
                                --publisher "${PUBLISHER_ID}" \
                                --extension-id "${EXTENSION_ID}" \
                                -t "${AZURE_DEVOPS_TOKEN}" \
                                --service-url https://marketplace.visualstudio.com \
                                --no-prompt \
                                --json 2>&1)
                            EXIT_CODE=$?
                            echo "${OUTPUT}"
                            echo "EXIT_CODE:${EXIT_CODE}"
                        ''',
                        returnStdout: true
                    ).trim()
                }
            }
            
            // Parse output and exit code
            def lines = tfxResult.readLines()
            def tfxExitCode = 1  // Default to failure for safety
            def tfxOutput = ''
            
            if (lines.size() > 0 && lines.last().startsWith("EXIT_CODE:")) {
                tfxExitCode = (lines.last().split(":")[1] as Integer)
                tfxOutput = lines[0..-2].join('\n').trim()
            } else {
                // Fallback: assume failure if we can't parse exit code
                // This is safer than assuming success - if parsing fails, something went wrong
                tfxOutput = tfxResult
                tfxExitCode = 1
                echo "‚ö†Ô∏è Warning: Could not parse exit code from tfx output, assuming failure"
            }
            
            // Check for specific authentication error message from tfx
            // tfx outputs: "error: Received response 401 (Not Authorized). Check that your personal access token is correct and hasn't expired."
            def authErrorMsg = "Received response 401 (Not Authorized). Check that your personal access token is correct and hasn't expired."
            def hasAuthError = tfxOutput.contains("error:") && tfxOutput.contains(authErrorMsg)
            
            // Validate that tfx produced meaningful output (JSON format expected with --json flag)
            def hasValidOutput = tfxOutput && tfxOutput.trim().length() > 0 && (tfxOutput.trim().startsWith("{") || tfxOutput.trim().startsWith("["))
            
            if (tfxExitCode == 0 && !hasAuthError && !tfxOutput.toLowerCase().contains("error:") && hasValidOutput) {
                result.status = 'SUCCESS'
                result.message = "Marketplace authentication successful"
                echo "‚úÖ Azure DevOps Marketplace authentication successful"
                echo "   Publisher: ${publisherId}"
                echo "   Extension: ${extensionId}"
            } else {
                def errorMsg = tfxOutput ?: "Unknown error (exit code: ${tfxExitCode})"
                
                if (!hasValidOutput && tfxExitCode == 0) {
                    // Check for empty or invalid output first
                    result.message = "Validation failed: No meaningful output from tfx (expected JSON response)"
                    echo "‚ùå Azure DevOps Marketplace validation failed: tfx returned success but produced no output"
                    echo "   Exit code: ${tfxExitCode}"
                    echo "   Output: ${tfxOutput ?: '(empty)'}"
                } else if (hasAuthError) {
                    // Check for authentication error (401) - specific tfx error message format
                    // Only treat as auth error if it matches the exact tfx error message pattern
                    result.message = "Unauthorized (401) ‚Äî Invalid or expired Personal Access Token"
                    echo "‚ùå Azure DevOps Marketplace authentication failed: Invalid or expired PAT"
                    echo "   Error: ${errorMsg.take(200)}"
                } else if (tfxOutput.contains("404") || tfxOutput.contains("Not Found")) {
                    result.message = "Not Found (404) ‚Äî Publisher or extension not found"
                    echo "‚ùå Azure DevOps Marketplace: Publisher or extension not found"
                    echo "   Error: ${errorMsg.take(200)}"
                } else {
                    // Other errors (network, tfx CLI issues, invalid extension ID, etc.) - not authentication related
                    result.message = "Marketplace validation failed (non-authentication error): ${errorMsg.take(100)}"
                    echo "‚ùå Azure DevOps Marketplace validation failed (non-authentication error)"
                    echo "   Exit code: ${tfxExitCode}"
                    echo "   Error: ${errorMsg.take(300)}"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Parses and validates credentials JSON file
 * Returns: [ok: boolean, username: string, password: string, url: string, message: string]
 */
def parseCredentialsFile(String filePath, String pluginName) {
    try {
        def creds = readJSON(text: readFile(file: filePath))
        
        if (!creds.secrets) {
            echo "ERROR: Invalid JSON: missing 'secrets' key"
            return [ok: false, message: "Invalid JSON: missing 'secrets' key"]
        }
        
        def secrets = creds.secrets
        def missingFields = []
        
        if (!secrets.username) missingFields.add('username')
        if (!secrets.password) missingFields.add('password')
        if (!secrets.url) missingFields.add('url')
        
        if (missingFields) {
            echo "ERROR: Missing required fields: ${missingFields.join(', ')}"
            return [ok: false, message: "Missing required fields: ${missingFields.join(', ')}"]
        }
        
        echo "Credentials parsed successfully"
        return [ok: true, username: secrets.username, password: secrets.password, url: secrets.url]
    } catch (Exception e) {
        echo "ERROR: Failed to parse credentials: ${e.message}"
        return [ok: false, message: "Failed to parse JSON: ${e.message}"]
    }
}

/**
 * Handles credential-related errors with helpful troubleshooting info
 */
def handleCredentialError(Exception e, String credFileId, String pluginName) {
    def errorMsg = e.message
    
    echo "ERROR: Credential error:"
    echo "   Message: ${errorMsg}"
    echo "   Credential ID: '${credFileId}'"
    
    def isCredentialNotFound = errorMsg?.toLowerCase()?.contains("not found") || 
                               errorMsg?.contains("CredentialNotFoundException")
    
    if (isCredentialNotFound) {
        echo "   Hint: Create secret file credential with ID '${credFileId}'"
        return "Credentials not configured yet"
    }
    
    return "Error: ${errorMsg?.take(50) ?: 'Unknown error'}"
}

def formatValidationResultsForJenkins(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "Plugin", "Status", "Message", "Timestamp"))
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "-" * 30, "-" * 10, "-" * 40, "-" * 19))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)
        def message = data.message ?: 'N/A'
        def timestamp = data.timestamp ?: 'N/A'

        table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
            displayName, status, message, timestamp))
    }

    table.append("```")
    return table.toString()
}

def formatValidationResultsForSlack(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s\n", "Plugin", "Status"))
    table.append(String.format("%-30s | %-10s\n", "-" * 30, "-" * 10))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)

        table.append(String.format("%-30s | %-10s\n", displayName, status))
    }

    table.append("```")
    return table.toString()
}

def getStatusEmoji(String status) {
    switch(status) {
        case 'SUCCESS': return '‚úÖ'
        case 'FAILURE': return '‚ùå'
        case 'SKIPPED': return '‚è≠Ô∏è'
        default: return status ?: 'N/A'
    }
}

/**
 * Installs JFrog CLI using official installer script
 */
def installJfrogCli() {
    def downloadStatus = sh(
        script: 'curl -fL https://install-cli.jfrog.io | sh',
        returnStatus: true
    )
    
    if (downloadStatus != 0) {
        error "Failed to download JFrog CLI (exit code: ${downloadStatus})"
    }
    
    def verifyStatus = sh(script: 'jf --version', returnStatus: true)
    
    if (verifyStatus != 0) {
        error "Failed to verify JFrog CLI installation (exit code: ${verifyStatus})"
    }
    
    echo "‚úÖ JFrog CLI installed successfully"
}

/**
 * Installs all prerequisites needed by validators
 * All apt-get operations happen here to avoid lock conflicts
 * Called during Initial Setup stage before parallel validations
 */
def installPrerequisites(Map pluginsMap, String pluginToValidate) {
    echo "Installing prerequisites for all validators..."
    
    // Check which plugins need prerequisites
    def needsNodeJs = false
    def needsCurlUnzip = false
    
    // Check if any active plugins need Node.js (Azure DevOps)
    if (pluginToValidate == "ALL" || pluginToValidate == "azure-devops-extension") {
        def azurePlugin = pluginsMap["azure-devops-extension"]
        if (azurePlugin && azurePlugin.active && azurePlugin.validatorType == "azure-devops") {
            needsNodeJs = true
        }
    }
    
    // Check if any active plugins need curl/unzip (TeamCity)
    if (pluginToValidate == "ALL" || pluginToValidate == "teamcity-jfrog-plugin") {
        def teamCityPlugin = pluginsMap["teamcity-jfrog-plugin"]
        if (teamCityPlugin && teamCityPlugin.active && teamCityPlugin.validatorType == "teamcity") {
            needsCurlUnzip = true
        }
    }
    
    // Install Node.js/npm if needed for Azure DevOps
    if (needsNodeJs) {
        echo "Installing Node.js/npm for Azure DevOps validator..."
        installNodeJs()
        
        // Install tfx-cli after npm is available
        echo "Installing tfx-cli for Azure DevOps validator..."
        installTfxCli()
    }
    
    // Install curl, unzip, and zip if needed for TeamCity
    if (needsCurlUnzip) {
        echo "Installing curl, unzip, and zip for TeamCity validator..."
        
        // Check and install curl
        def curlAvailable = sh(
            script: 'curl --version > /dev/null 2>&1 && echo "YES" || echo "NO"',
            returnStdout: true
        ).trim() == 'YES'
        
        if (!curlAvailable) {
            echo "Installing curl..."
            def curlInstallStatus = installPackageWithRetry('curl')
            if (curlInstallStatus != 0) {
                error "Failed to install curl. Exit code: ${curlInstallStatus}"
            }
            echo "‚úÖ curl installed successfully"
        } else {
            echo "‚úÖ curl already available"
        }
        
        // Check and install unzip
        def unzipAvailable = sh(
            script: 'unzip -v > /dev/null 2>&1 && echo "YES" || echo "NO"',
            returnStdout: true
        ).trim() == 'YES'
        
        if (!unzipAvailable) {
            echo "Installing unzip..."
            def unzipInstallStatus = installPackageWithRetry('unzip')
            if (unzipInstallStatus != 0) {
                error "Failed to install unzip. Exit code: ${unzipInstallStatus}"
            }
            echo "‚úÖ unzip installed successfully"
        } else {
            echo "‚úÖ unzip already available"
        }
        
        // Check and install zip
        def zipAvailable = sh(
            script: 'zip -v > /dev/null 2>&1 && echo "YES" || echo "NO"',
            returnStdout: true
        ).trim() == 'YES'
        
        if (!zipAvailable) {
            echo "Installing zip..."
            def zipInstallStatus = installPackageWithRetry('zip')
            if (zipInstallStatus != 0) {
                error "Failed to install zip. Exit code: ${zipInstallStatus}"
            }
            echo "‚úÖ zip installed successfully"
        } else {
            echo "‚úÖ zip already available"
        }
        
        // Install Java (required for Groovy)
        echo "Installing Java for Groovy..."
        installJava()
        
        // Install Groovy using SDKMAN
        echo "Installing Groovy for TeamCity validator..."
        installGroovy()
    }
    
    echo "‚úÖ All prerequisites installed successfully"
}

/**
 * Installs tfx-cli using npm
 * Required for Azure DevOps Marketplace validation
 * Assumes npm is already installed (should be called after installNodeJs)
 */
def installTfxCli() {
    // Check if tfx is already installed
    def checkStatus = sh(
        script: 'which tfx || command -v tfx || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (checkStatus != "NOT_FOUND" && checkStatus) {
        echo "‚úÖ tfx-cli is already installed at: ${checkStatus}"
        return
    }
    
    // Verify npm is available
    def npmCheck = sh(
        script: 'which npm || command -v npm || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (npmCheck == "NOT_FOUND" || !npmCheck) {
        error "npm is not available. Node.js should be installed before calling installTfxCli()"
    }
    
    echo "Installing tfx-cli using npm..."
    def installStatus = sh(
        script: 'npm install -g tfx-cli',
        returnStatus: true
    )
    
    if (installStatus != 0) {
        error "Failed to install tfx-cli (exit code: ${installStatus}). Ensure npm is properly configured."
    }
    
    // Verify installation
    def verifyStatus = sh(
        script: 'tfx --version',
        returnStatus: true
    )
    
    if (verifyStatus != 0) {
        error "Failed to verify tfx-cli installation (exit code: ${verifyStatus})"
    }
    
    echo "‚úÖ tfx-cli installed successfully"
}

/**
 * Installs a package using apt-get with retry logic to handle lock conflicts
 * Waits for apt-get lock to be released if another process is using it
 * This is used as a last resort fallback
 */
def installPackageWithRetry(String packageName, int maxRetries = 5, int waitSeconds = 5) {
    def retryCount = 0
    def installStatus = 1
    
    while (retryCount < maxRetries && installStatus != 0) {
        // Check if apt-get lock exists and wait if locked
        def lockCheck = sh(
            script: '''
                if [ -f /var/lib/apt/lists/lock ] || [ -f /var/lib/dpkg/lock ] || [ -f /var/cache/apt/archives/lock ]; then
                    echo "LOCKED"
                else
                    echo "FREE"
                fi
            ''',
            returnStdout: true
        ).trim()
        
        if (lockCheck == "LOCKED") {
            if (retryCount < maxRetries - 1) {
                echo "apt-get lock detected (attempt ${retryCount + 1}/${maxRetries}), waiting ${waitSeconds} seconds..."
                sleep(waitSeconds)
                retryCount++
                continue
            } else {
                echo "WARNING: apt-get lock still present after ${maxRetries - 1} retries, attempting installation anyway..."
            }
        }
        
        // Attempt installation
        installStatus = sh(
            script: "apt-get update -y && apt-get install -y ${packageName}",
            returnStatus: true
        )
        
        if (installStatus == 0) {
            return 0
        }
        
        // If installation failed due to lock, wait and retry
        if (installStatus == 100) {
            echo "Installation failed with exit code 100 (likely lock conflict)"
            if (retryCount < maxRetries - 1) {
                echo "Waiting ${waitSeconds} seconds before retry..."
                sleep(waitSeconds)
                retryCount++
                continue
            }
        }
        
        retryCount++
    }
    
    return installStatus
}

/**
 * Installs Java (OpenJDK) required for Groovy
 * Sets JAVA_HOME environment variable
 */
def installJava() {
    // Check if Java is already installed
    def javaCheck = sh(
        script: 'which java || command -v java || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (javaCheck != "NOT_FOUND" && javaCheck) {
        echo "‚úÖ Java is already installed at: ${javaCheck}"
        // Set JAVA_HOME if not already set
        def javaHome = sh(
            script: 'echo $JAVA_HOME || dirname $(dirname $(readlink -f $(which java)))',
            returnStdout: true
        ).trim()
        
        if (!javaHome || javaHome == '' || javaHome.contains('NOT_FOUND')) {
            // Try to find JAVA_HOME from java installation
            javaHome = sh(
                script: 'dirname $(dirname $(readlink -f $(which java)))',
                returnStdout: true
            ).trim()
        }
        
        if (!javaHome || javaHome == '') {
            javaHome = '/usr/lib/jvm/java-11-openjdk-amd64'
        }
        
        env.JAVA_HOME = javaHome
        echo "   JAVA_HOME set to: ${javaHome}"
        return
    }
    
    echo "Installing Java (OpenJDK 11)..."
    def javaInstallStatus = installPackageWithRetry('openjdk-11-jdk')
    
    if (javaInstallStatus != 0) {
        error "Failed to install Java. Exit code: ${javaInstallStatus}"
    }
    
    // Set JAVA_HOME
    def javaHome = sh(
        script: 'update-alternatives --list java | head -1 | sed "s|/bin/java||" || echo "/usr/lib/jvm/java-11-openjdk-amd64"',
        returnStdout: true
    ).trim()
    
    if (!javaHome || javaHome == '') {
        javaHome = '/usr/lib/jvm/java-11-openjdk-amd64'
    }
    
    env.JAVA_HOME = javaHome
    echo "‚úÖ Java installed successfully"
    echo "   JAVA_HOME set to: ${javaHome}"
}

/**
 * Installs Groovy using SDKMAN
 * Required for JetBrains Plugin Repository validation
 * Assumes curl, unzip, and Java are already installed (should be called after prerequisites)
 */
def installGroovy() {
    // Check if Groovy is already installed
    def groovyCheck = sh(
        script: 'which groovy || command -v groovy || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (groovyCheck != "NOT_FOUND" && groovyCheck) {
        echo "‚úÖ Groovy is already installed at: ${groovyCheck}"
        def groovyVersion = sh(script: 'groovy --version', returnStdout: true).trim()
        echo "   ${groovyVersion.take(50)}"
        return
    }
    
    echo "Installing Groovy using SDKMAN..."
    
    // Install Groovy using SDKMAN (curl, unzip, and Java should already be available)
    // Use bash explicitly since SDKMAN requires bash-specific syntax
    // Set JAVA_HOME before installing Groovy
    def javaHome = env.JAVA_HOME ?: sh(
        script: 'update-alternatives --list java | head -1 | sed "s|/bin/java||" || echo "/usr/lib/jvm/java-11-openjdk-amd64"',
        returnStdout: true
    ).trim()
    
    if (!javaHome || javaHome == '') {
        javaHome = '/usr/lib/jvm/java-11-openjdk-amd64'
    }
    
    def installStatus = sh(
        script: """
            bash -c '
            export JAVA_HOME="${javaHome}"
            export PATH="\$JAVA_HOME/bin:\$PATH"
            
            # Install SDKMAN if not present
            if [ ! -d "\$HOME/.sdkman" ]; then
                curl -s "https://get.sdkman.io" | bash || exit 1
            fi
            
            # Source SDKMAN
            export SDKMAN_DIR="\$HOME/.sdkman"
            if [ -s "\$HOME/.sdkman/bin/sdkman-init.sh" ]; then
                source "\$HOME/.sdkman/bin/sdkman-init.sh" || true
            fi
            
            # Install Groovy (non-interactive, use default version)
            sdk install groovy < /dev/null || exit 1
            
            # Verify installation
            groovy --version || exit 1
            '
        """,
        returnStatus: true
    )
    
    if (installStatus != 0) {
        error "Failed to install Groovy via SDKMAN. Exit code: ${installStatus}"
    }
    
    // Verify Groovy installation using bash
    def groovyVerify = sh(
        script: """
            bash -c '
            export JAVA_HOME="${javaHome}"
            export PATH="\$JAVA_HOME/bin:\$PATH"
            if [ -s "\$HOME/.sdkman/bin/sdkman-init.sh" ]; then
                source "\$HOME/.sdkman/bin/sdkman-init.sh" || true
            fi
            groovy --version
            '
        """,
        returnStatus: true
    )
    
    if (groovyVerify != 0) {
        error "Failed to verify Groovy installation (exit code: ${groovyVerify})"
    }
    
    def groovyVersionOutput = sh(
        script: """
            bash -c '
            export JAVA_HOME="${javaHome}"
            export PATH="\$JAVA_HOME/bin:\$PATH"
            if [ -s "\$HOME/.sdkman/bin/sdkman-init.sh" ]; then
                source "\$HOME/.sdkman/bin/sdkman-init.sh" || true
            fi
            groovy --version
            '
        """,
        returnStdout: true
    ).trim()
    echo "‚úÖ Groovy installed successfully"
    echo "   ${groovyVersionOutput.take(80)}"
}

/**
 * Installs Node.js (which includes npm)
 * Uses NodeSource repository for Ubuntu systems
 */
def installNodeJs() {
    // Check if Node.js is already installed
    def nodeCheck = sh(
        script: 'which node || command -v node || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (nodeCheck != "NOT_FOUND" && nodeCheck) {
        echo "‚úÖ Node.js is already installed at: ${nodeCheck}"
        return
    }
    
    echo "Installing Node.js..."
    
    // Use system package manager directly (safer than curl | bash pattern)
    // This avoids security risks of downloading and executing remote scripts
    def installStatus = sh(
        script: '''
            if apt-get update && apt-get install -y nodejs npm; then
                exit 0
            else
                exit 1
            fi
        ''',
        returnStatus: true
    )
    
    if (installStatus != 0) {
        error "Failed to install Node.js/npm. Please ensure apt package manager is available and has access to nodejs package."
    }
    
    // Verify Node.js installation
    def nodeVerify = sh(
        script: 'node --version',
        returnStatus: true
    )
    
    if (nodeVerify != 0) {
        error "Failed to verify Node.js installation (exit code: ${nodeVerify})"
    }
    
    // Verify npm installation
    def npmVerify = sh(
        script: 'npm --version',
        returnStatus: true
    )
    
    if (npmVerify != 0) {
        error "Failed to verify npm installation (exit code: ${npmVerify})"
    }
    
    def nodeVersion = sh(script: 'node --version', returnStdout: true).trim()
    def npmVersion = sh(script: 'npm --version', returnStdout: true).trim()
    
    echo "‚úÖ Node.js installed successfully (Node.js: ${nodeVersion}, npm: ${npmVersion})"
}

/**
 * Tests Nexus Repository connection using /service/local/status endpoint
 * Returns: [ok: boolean, message: string, username: string, status: int]
 * Uses shell commands to avoid Jenkins sandbox restrictions
 */
def nxPing(String nexusUrl, String username, String password) {
    try {
        def endpoint = "${nexusUrl}/service/local/status"
        
        // Use HEAD request (-I) which is lighter and sufficient for authentication check
        def response = ''
        withEnv([
            "NEXUS_USER=${username}",
            "NEXUS_PASSWORD=${password}",
            "NEXUS_ENDPOINT=${endpoint}"
        ]) {
            response = sh(
                script: '''
                    curl -s -I -w '\\n%{http_code}' \
                    --user "${NEXUS_USER}:${NEXUS_PASSWORD}" \
                    -H 'Accept: application/json' \
                    --connect-timeout 5 \
                    --max-time 10 \
                    "${NEXUS_ENDPOINT}" 2>&1
                ''',
                returnStdout: true
            ).trim()
        }
        
        def lines = response.readLines()
        def statusCode = lines.last() as Integer
        
        // Success - credentials are valid
        if (statusCode == 200 || statusCode == 204) {
            echo "SUCCESS: Nexus Repository connection successful"
            return [ok: true, message: "Credentials valid (${statusCode} OK)", username: username, status: statusCode]
        }
        
        // Authentication failed
        if (statusCode == 401) {
            return [ok: false, message: "Unauthorized (401) ‚Äî Invalid username/password", status: 401]
        }
        
        // Permission denied
        if (statusCode == 403) {
            return [ok: false, message: "Forbidden (403) ‚Äî Valid credentials but insufficient permissions", status: 403]
        }
        
        // Endpoint not supported or other error
        return [ok: false, message: "Endpoint not supported (${statusCode})", status: statusCode]

    } catch (Exception e) {
        return [ok: false, message: "Connection error: ${e.message}", status: -1]
    }
}

/**
 * Parses TeamCity/JetBrains Plugin Repository credentials JSON file
 * Expected format: { "secrets": { "token": "...", "url": "..." } }
 * URL is optional and defaults to https://plugins.jetbrains.com
 * Returns: [ok: boolean, token: string, url: string, message: string]
 */
def parseTeamCityCredentialsFile(String filePath, String pluginName) {
    try {
        def creds = readJSON(text: readFile(file: filePath))
        
        if (!creds.secrets) {
            echo "ERROR: Invalid JSON: missing 'secrets' key"
            return [ok: false, message: "Invalid JSON: missing 'secrets' key"]
        }
        
        def secrets = creds.secrets
        
        if (!secrets.token) {
            echo "ERROR: Missing required field: token"
            return [ok: false, message: "Missing required field: token"]
        }
        
        def url = secrets.url ?: 'https://plugins.jetbrains.com'
        
        echo "Credentials parsed successfully"
        return [ok: true, token: secrets.token, url: url]
    } catch (Exception e) {
        echo "ERROR: Failed to parse credentials: ${e.message}"
        return [ok: false, message: "Failed to parse JSON: ${e.message}"]
    }
}

/**
 * Validates JetBrains Plugin Repository token using the plugin-repository-rest-client library
 * Uses the test script file that works locally, ensuring consistency
 * Token is passed via environment variable to avoid writing sensitive data to disk
 * Returns: [ok: boolean, message: string, vendorName: string, vendorUrl: string]
 */
def validateJetBrainsPluginRepository(String token, String baseUrl = 'https://plugins.jetbrains.com') {
    def scriptFile = 'test-jetbrains-plugin-repo-validation.groovy'
    def output = ''
    def exitCode = 0
    def scriptCreated = false
    
    try {
        // Try to read the test script from workspace first (preferred method)
        // If not found, create inline fallback version
        def scriptPath = "jenkins/${scriptFile}"
        def scriptContent = null
        
        // Attempt to read script from workspace
        try {
            scriptContent = readFile(file: scriptPath)
            writeFile(file: scriptFile, text: scriptContent)
            scriptCreated = true
            echo "Using script from workspace: ${scriptPath}"
        } catch (Exception readEx) {
            // Script file doesn't exist in workspace, create inline fallback version
            echo "Script file not found in workspace (${scriptPath}), creating inline fallback version"
            scriptContent = """#!/usr/bin/env groovy

// @Grab annotations must appear before any executable code
@Grab('org.jetbrains.intellij:plugin-repository-rest-client:2.0.50')
@Grab('org.slf4j:slf4j-simple:2.0.16')

import org.jetbrains.intellij.pluginRepository.PluginRepository
import org.jetbrains.intellij.pluginRepository.PluginRepositoryException
import org.jetbrains.intellij.pluginRepository.PluginRepositoryFactory
import org.jetbrains.intellij.pluginRepository.model.PluginVendorBean

// Force unbuffered output and verify script is executing
System.out.flush()
System.err.flush()
System.out.println "Script started"
System.out.flush()

System.out.println "Dependencies loaded"
System.out.flush()

String pluginUrl = System.getenv('JETBRAINS_PLUGIN_URL') ?: 'https://plugins.jetbrains.com'
String pluginToken = System.getenv('JETBRAINS_PLUGIN_TOKEN')

// Force output flushing to ensure output is visible
System.out.flush()
System.err.flush()

if (pluginToken == null || pluginToken.trim().isEmpty()) {
    System.out.println "ERROR: Missing JETBRAINS_PLUGIN_TOKEN environment variable"
    System.out.println ""
    System.out.println "Usage:"
    System.out.println "  export JETBRAINS_PLUGIN_TOKEN='your-token-here'"
    System.out.println "  groovy test-jetbrains-plugin-repo-validation.groovy"
    System.out.println ""
    System.out.println "FAILURE|ERROR:Missing JETBRAINS_PLUGIN_TOKEN environment variable"
    System.out.flush()
    System.exit(1)
}

System.out.println "Testing JetBrains Plugin Repository connection..."
System.out.println "URL: \${pluginUrl}"
System.out.println "Token: \${pluginToken ? '***' + pluginToken.takeRight(4) : 'NOT SET'}"
System.out.println ""
System.out.flush()

try {
    PluginRepository repository = PluginRepositoryFactory.create(pluginUrl, pluginToken)
    PluginVendorBean vendor = repository.getVendorManager().getVendorOfCurrentUser()
    
    if (vendor == null) {
        throw new PluginRepositoryException('Authenticated but no vendor is associated with this token')
    }
    
    String vendorName = vendor.getPublicName() ?: vendor.getName()
    String vendorUrl = vendor.getUrl() ?: 'N/A'
    
    System.out.println "‚úÖ SUCCESS: Credentials valid"
    System.out.println "Vendor Name: \${vendorName}"
    System.out.println "Vendor URL: \${vendorUrl}"
    System.out.println ""
    System.out.println "SUCCESS|VENDOR_NAME:\${vendorName}|VENDOR_URL:\${vendorUrl}"
    System.out.flush()
    
    // Explicitly exit with success code
    System.exit(0)
    
} catch (PluginRepositoryException ex) {
    System.err.println "‚ùå FAILURE: \${ex.message}"
    System.err.println ""
    System.out.println "FAILURE|ERROR:\${ex.message}"
    System.out.flush()
    System.err.flush()
    System.exit(1)
} catch (Exception ex) {
    System.err.println "‚ùå ERROR: \${ex.message}"
    ex.printStackTrace()
    System.err.println ""
    System.out.println "FAILURE|ERROR:\${ex.message}"
    System.out.flush()
    System.err.flush()
    System.exit(1)
}
"""
            writeFile(file: scriptFile, text: scriptContent)
            scriptCreated = true
        }
        
        // Get absolute path to ensure we can execute it from any directory
        // Only attempt this if we successfully read/wrote the script file
        if (scriptCreated) {
            try {
                def absScriptPath = sh(
                    script: "readlink -f \"${scriptFile}\" || realpath \"${scriptFile}\" || echo \"${scriptFile}\"",
                    returnStdout: true
                ).trim()
                if (absScriptPath && absScriptPath != scriptFile) {
                    scriptFile = absScriptPath
                    echo "Using absolute path: ${scriptFile}"
                }
            } catch (Exception pathEx) {
                // Non-critical: continue with relative path if absolute path resolution fails
                echo "Warning: Could not resolve absolute path for script file: ${pathEx.message}"
            }
        }
        
        // Set executable permissions on the script file and ensure it's readable
        sh("chmod 755 \"${scriptFile}\" || chmod 700 \"${scriptFile}\" || true")
        
        // Verify script file exists and is readable
        def scriptExistsCheck = sh(
            script: "test -f \"${scriptFile}\" && test -r \"${scriptFile}\" && echo 'EXISTS' || echo 'NOT_FOUND'",
            returnStdout: true
        ).trim()
        
        if (scriptExistsCheck != 'EXISTS') {
            return [ok: false, message: "Script file not found or not readable: ${scriptFile}"]
        }
        
        echo "Script file verified: ${scriptFile}"
        
        // Execute the Groovy script with token passed via environment variable
        // The token is already masked by MaskPasswordsBuildWrapper in the calling function
        withEnv([
            "JETBRAINS_PLUGIN_TOKEN=${token}",
            "JETBRAINS_PLUGIN_URL=${baseUrl}"
        ]) {
            // Verify Groovy is available (should be installed in Initial Setup)
            def groovyCheck = sh(
                script: "which groovy || command -v groovy || echo 'NOT_FOUND'",
                returnStdout: true
            ).trim()
            
            if (groovyCheck == 'NOT_FOUND' || !groovyCheck) {
                return [ok: false, message: "Groovy is not available. It should have been installed during Initial Setup stage."]
            }
            
            echo "Groovy found at: ${groovyCheck}"
            
            // Source SDKMAN if it exists (for Groovy installed via SDKMAN)
            // Otherwise use groovy from PATH
            // Use bash explicitly since SDKMAN requires bash-specific syntax
            // Set JAVA_HOME for Groovy execution
            def javaHome = env.JAVA_HOME ?: sh(
                script: 'update-alternatives --list java | head -1 | sed "s|/bin/java||" || echo "/usr/lib/jvm/java-11-openjdk-amd64"',
                returnStdout: true
            ).trim()
            
            if (!javaHome || javaHome == '') {
                javaHome = '/usr/lib/jvm/java-11-openjdk-amd64'
            }
            
            // Verify Groovy can execute
            def groovyVersionCheck = sh(
                script: """
                    bash -c '
                    export JAVA_HOME="${javaHome}"
                    export PATH="\$JAVA_HOME/bin:\$PATH"
                    if [ -f "\$HOME/.sdkman/bin/sdkman-init.sh" ]; then
                        source "\$HOME/.sdkman/bin/sdkman-init.sh" || true
                    fi
                    groovy --version 2>&1 || echo "GROOVY_VERSION_CHECK_FAILED"
                    '
                """,
                returnStdout: true
            ).trim()
            
            if (groovyVersionCheck.contains('GROOVY_VERSION_CHECK_FAILED') || !groovyVersionCheck) {
                return [ok: false, message: "Groovy found but cannot execute. Check Java installation and Groovy configuration. Error: ${groovyVersionCheck.take(200)}"]
            }
            
            echo "Groovy version check: ${groovyVersionCheck.take(100)}"
            
            // Execute script and capture both output and exit code
            // Use set +e to continue even if script fails, so we can capture exit code
            // Capture both stdout and stderr (2>&1 redirects stderr to stdout)
            // Force unbuffered output with stdbuf if available
            def result = sh(
                script: """
                    bash -c '
                    set +e
                    export JAVA_HOME="${javaHome}"
                    export PATH="\$JAVA_HOME/bin:\$PATH"
                    if [ -f "\$HOME/.sdkman/bin/sdkman-init.sh" ]; then
                        source "\$HOME/.sdkman/bin/sdkman-init.sh" || true
                    fi
                    # Execute groovy script with unbuffered output and capture all output (stdout + stderr)
                    # Use stdbuf if available to ensure unbuffered output, otherwise use groovy directly
                    # Wrap in a subshell to ensure we capture all output even if script fails early
                    (
                        if command -v stdbuf > /dev/null 2>&1; then
                            stdbuf -oL -eL groovy "${scriptFile}" 2>&1
                        else
                            groovy "${scriptFile}" 2>&1
                        fi
                    )
                    # Capture exit code immediately after script execution, before any error handler
                    EXIT_CODE=\$?
                    # If script failed, output error message (but don't change exit code)
                    if [ \$EXIT_CODE -ne 0 ]; then
                        echo "ERROR: Script execution failed or produced no output"
                        echo "FAILURE|ERROR:Script execution failed - check Groovy installation and dependencies"
                    fi
                    # Print exit code to stdout so it gets captured
                    echo "EXIT_CODE:\${EXIT_CODE}"
                    exit 0
                    '
                """,
                returnStdout: true
            ).trim()
            
            // Parse exit code from output
            def lines = result.readLines()
            if (lines.size() > 0 && lines.last().startsWith("EXIT_CODE:")) {
                def exitCodeStr = lines.last().split(":")[1]?.trim()
                // Validate exit code is a valid integer before parsing
                if (exitCodeStr && exitCodeStr.matches(/^-?\d+$/)) {
                    try {
                        exitCode = exitCodeStr as Integer
                    } catch (NumberFormatException e) {
                        echo "ERROR: Failed to parse exit code '${exitCodeStr}' as integer: ${e.message}"
                        exitCode = 1  // Treat parsing failure as script failure for safety
                    }
                } else {
                    echo "ERROR: Invalid exit code format '${exitCodeStr}' (expected integer). Treating as failure."
                    exitCode = 1  // Treat invalid format as script failure for safety
                }
                output = lines.size() > 1 ? lines[0..-2].join('\n').trim() : ''
            } else {
                output = result
            }
        }
        
        // Log full output for debugging (will be masked if token appears)
        if (output && output.trim()) {
            echo "Script output (full):"
            echo "---"
            echo output
            echo "---"
        } else {
            echo "WARNING: No output captured from script"
            echo "This could indicate:"
            echo "  1. @Grab dependencies failed to download silently"
            echo "  2. Script execution was interrupted"
            echo "  3. Output buffering issue"
            echo "  4. Environment variables not set correctly"
            if (exitCode == 0) {
                echo "Note: Script exited with code 0 (success) but produced no output"
            }
        }
        echo "Script exit code: ${exitCode}"
        
        // Parse output - look for SUCCESS| or FAILURE| markers
        // The script outputs: "SUCCESS|VENDOR_NAME:...|VENDOR_URL:..." or "FAILURE|ERROR:..."
        // Search through all lines to find the marker (it might be mixed with other output)
        def successLine = output.readLines().find { it.contains('SUCCESS|') }
        def failureLine = output.readLines().find { it.contains('FAILURE|') }
        
        // Primary decision: Exit code determines success/failure
        // Exit code 0 = success, non-zero = failure
        if (exitCode == 0) {
            // Script exited successfully - parse output for details if available
            if (successLine) {
                // Parse the SUCCESS line: "SUCCESS|VENDOR_NAME:...|VENDOR_URL:..."
                def parts = successLine.split('\\|')
                def vendorName = ''
                def vendorUrl = ''
                
                parts.each { part ->
                    if (part.startsWith('VENDOR_NAME:')) {
                        vendorName = part.substring('VENDOR_NAME:'.length())
                    } else if (part.startsWith('VENDOR_URL:')) {
                        vendorUrl = part.substring('VENDOR_URL:'.length())
                    }
                }
                
                def message = "Credentials valid"
                if (vendorName && vendorName != 'N/A') {
                    message += " ‚Äî Vendor: ${vendorName}"
                }
                if (vendorUrl && vendorUrl != 'N/A') {
                    message += " (${vendorUrl})"
                }
                
                echo "Parsed SUCCESS line: ${successLine}"
                return [ok: true, message: message, vendorName: vendorName, vendorUrl: vendorUrl]
            } else {
                // Exit code 0 but no SUCCESS| marker - still treat as success
                // This handles cases where script succeeds but output format differs
                echo "Script exited successfully (exit code 0) but no SUCCESS| marker found"
                return [ok: true, message: "Validation completed successfully (exit code: 0)"]
            }
        } else {
            // Exit code is non-zero - script failed
            if (failureLine) {
                // Parse the FAILURE line: "FAILURE|ERROR:..."
                def parts = failureLine.split('\\|')
                def errorMsg = 'Unknown error'
                
                parts.each { part ->
                    if (part.startsWith('ERROR:')) {
                        errorMsg = part.substring('ERROR:'.length())
                    }
                }
                
                echo "Parsed FAILURE line: ${failureLine}"
                return [ok: false, message: "JetBrains credentials invalid or repository unreachable: ${errorMsg}"]
            } else {
                // Non-zero exit code but no FAILURE| marker - parse error details
                def errorDetails = output ?: 'No output from script'
                errorDetails += " (exit code: ${exitCode})"
                
                // Check for common error patterns
                def lowerOutput = output.toLowerCase()
                
                if (lowerOutput.contains('@grab') || lowerOutput.contains('could not resolve') || 
                    lowerOutput.contains('resolveexception') || lowerOutput.contains('grape') ||
                    lowerOutput.contains('dependency resolution') || lowerOutput.contains('maven')) {
                    return [ok: false, message: "Failed to download @Grab dependencies. Ensure Groovy has internet access and can reach Maven repositories. Check network/firewall settings. Output: ${errorDetails.take(500)}"]
                } else if (lowerOutput.contains('no such file') || lowerOutput.contains('command not found') || 
                           lowerOutput.contains('groovy: command not found') || lowerOutput.contains('cannot find')) {
                    return [ok: false, message: "Groovy not found or script file not accessible. Verify Groovy installation and script path. Output: ${errorDetails.take(500)}"]
                } else if (lowerOutput.contains('connection') || lowerOutput.contains('timeout') || 
                           lowerOutput.contains('refused') || lowerOutput.contains('unknownhostexception') ||
                           lowerOutput.contains('network') || lowerOutput.contains('unreachable')) {
                    return [ok: false, message: "Network error connecting to JetBrains Plugin Repository. Check connectivity to ${baseUrl}. Output: ${errorDetails.take(500)}"]
                } else if (lowerOutput.contains('authentication') || lowerOutput.contains('unauthorized') ||
                           lowerOutput.contains('401') || lowerOutput.contains('403')) {
                    return [ok: false, message: "Authentication failed. Token may be invalid or expired. Output: ${errorDetails.take(500)}"]
                } else {
                    return [ok: false, message: "Script execution failed (exit code: ${exitCode}). Output: ${errorDetails.take(500)}"]
                }
            }
        }
        
    } catch (Exception e) {
        // Handle exceptions (cleanup happens in finally block)
        def errorMsg = e.message ?: 'Unknown error'
        echo "Exception during validation: ${errorMsg}"
        e.printStackTrace()
        
        if (errorMsg.contains('No such file or directory') || errorMsg.contains('command not found')) {
            return [ok: false, message: "Groovy not available or @Grab dependencies failed to load: ${errorMsg}"]
        }
        return [ok: false, message: "Connection error: ${errorMsg}"]
    } finally {
        // Clean up script file securely (only if we created it)
        // This ensures cleanup happens even with early returns or exceptions
        try {
            if (scriptCreated) {
                sh("rm -f \"${scriptFile}\" || true")
            }
        } catch (Exception cleanupEx) {
            // Ignore cleanup errors
            echo "Warning: Failed to cleanup script file: ${cleanupEx.message}"
        }
    }
}
