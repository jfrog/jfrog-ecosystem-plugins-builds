// Jenkins CI pipeline for validating JFrog Artifactory credentials across multiple ecosystem plugins.
// Runs nightly to ensure credentials are properly configured and functional.
// Notifies Slack with validation results in markdown table format.

node("docker-ubuntu20-xlarge") {
    properties([
        parameters([
            string(
                name: 'SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION',
                defaultValue: 'jfrog-ecosystem-plugins-notifications',
                description: 'Slack channel for credential validation notifications'
            ),
            choice(
                name: 'PLUGIN_TO_VALIDATE',
                choices: ['ALL', 'jenkins-jfrog-plugin', 'gradle-jfrog-plugin', 'bamboo-jfrog-plugin', 'teamcity-jfrog-plugin', 'azure-devops-extension', 'artifactory-maven-plugin'],
                description: 'Select specific plugin to validate or ALL for all plugins'
            )
        ]),
        pipelineTriggers([
            cron('0 1 * * *')
        ])
    ])
    
    try {
        validationResults = [:]
        buildStatus = 'SUCCESS'
        cliExecutableName = 'jf'
        formattedDate = new Date().format('yyyy-MM-dd HH:mm:ss')
        env.JFROG_CLI_LOG_LEVEL = "ERROR"  // Minimize logging for security
        slackChannelName = params.SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION
        pluginToValidate = params.PLUGIN_TO_VALIDATE
        
        // Debug: Log the actual parameter value being used
        echo "üì¢ Slack Channel Parameter: '${slackChannelName}'"
        echo "   (Note: To change this, update the parameter in Jenkins UI: Job ‚Üí Configure ‚Üí Parameters)"
        
        // ============================================================================
        // PLUGIN REGISTRY - Add your plugins here (Plug & Play)
        // ============================================================================
        // Just add an entry with credFileId, displayName, and validatorType
        // The system will automatically handle the rest!
        //
        // validatorType options:
        //   - "jfrog"   : Uses JFrog CLI
        //   - "nexus"   : Uses Nexus REST API (for Gradle)
        //   - "github"  : Uses GitHub API to trigger/check workflows
        //   - "custom"  : Uses custom validator function (provide customValidator)
        //   - "skip"    : Skip validation (or omit validatorType entirely)
        //
        // If validatorType is not specified or set to "skip", the plugin will be SKIPPED
        // ============================================================================
        
        def pluginsMap = [
            "jenkins-jfrog-plugin": [
                credFileId: "jenkins-jfrog-creds",
                displayName: "Jenkins JFrog Plugin",
                active: true,
                validatorType: "jfrog"
            ],
            "gradle-jfrog-plugin": [
                credFileId: "gradle-plugin-creds-json",
                displayName: "Gradle JFrog Plugin",
                active: true,
                validatorType: "nexus"
            ],
            "bamboo-jfrog-plugin": [
                credFileId: "bamboo-plugin-creds-json",
                displayName: "Bamboo JFrog Plugin",
                active: false,
                validatorType: "jfrog"
            ],
            "teamcity-jfrog-plugin": [
                credFileId: "teamcity-plugin-creds-json",
                displayName: "TeamCity JFrog Plugin",
                active: false,
                validatorType: "jfrog"
            ],
            "azure-devops-extension": [
                credFileId: "azure-devops-plugin-creds-json",
                displayName: "Azure DevOps Extension",
                active: false,
                validatorType: "jfrog"
            ],
            "artifactory-maven-plugin": [
                credFileId: "artifactory-maven-plugin-github-creds",
                displayName: "Artifactory Maven Plugin",
                active: true,
                validatorType: "github",
                githubBranch: "master"  // Artifactory Maven Plugin uses master branch
            ]
            
            // ========================================
            // TO ADD A NEW PLUGIN - Just copy this template:
            // ========================================
            // ,"my-new-plugin": [
            //     credFileId: "my-plugin-creds",
            //     displayName: "My New Plugin",
            //     active: false,
            //     validatorType: "skip"  // Options: "jfrog", "nexus", "github", "custom", "skip"
            //                            // Leave as "skip" or omit validatorType to skip validation
            // ]
        ]
        
        dir('credential-validation-temp') {
            stage('Initial Setup') {
                try {
                    script {
                        installJfrogCli()
                        echo "JFrog CLI installed successfully"
                    }
                } catch (e) {
                    echo "Error during initial setup: ${e}"
                    throw e
                }
            }
            
            script {
                def tasksToRun = createValidationTasks(pluginsMap, pluginToValidate)
                parallel(tasksToRun)
            }
        }
    } catch (e) {
        echo "ERROR: Pipeline failed with exception: ${e}"
        buildStatus = 'FAILURE'
        throw e
    } finally {
        stage('Send Notifications') {
            sendSlackNotification(validationResults, buildStatus, slackChannelName, formattedDate)
        }
    }
}

def sendSlackNotification(Map validationResults, String buildStatus, String channelName, String timestamp) {
    def statusCounts = calculateStatusCounts(validationResults)
    def notificationConfig = determineNotificationConfig(buildStatus, statusCounts)
    
    // Print detailed results to Jenkins console
    def detailedTable = formatValidationResultsForJenkins(validationResults)
    echo "=" * 80
    echo "VALIDATION RESULTS"
    echo "=" * 80
    echo detailedTable
    echo "=" * 80
    
    // Create compact message for Slack
    def slackTable = formatValidationResultsForSlack(validationResults)
    def message = buildSlackMessage(notificationConfig, statusCounts, timestamp, slackTable)
    
    // Try to send Slack notification
    try {
        if (channelName && channelName.trim() != '') {
            slackSend(
                channel: "#${channelName}",
                message: message,
                color: notificationConfig.color
            )
            echo "SUCCESS: Slack notification sent to #${channelName}"
        } else {
            echo "WARNING: Slack notification skipped: No channel name configured"
        }
    } catch (Exception slackEx) {
        echo "WARNING: Slack notification failed (non-critical): ${slackEx.message}"
        echo "   Results are printed above."
    }
}

def calculateStatusCounts(Map validationResults) {
    return [
        success: validationResults.count { k, v -> v.status == 'SUCCESS' },
        failure: validationResults.count { k, v -> v.status == 'FAILURE' },
        skipped: validationResults.count { k, v -> v.status == 'SKIPPED' }
    ]
}

def determineNotificationConfig(String buildStatus, Map statusCounts) {
    if (buildStatus != 'SUCCESS') {
        return [
            icon: '‚ùå',
            title: 'Credential Validation Pipeline Failed',
            color: 'danger',
            mentionChannel: true
        ]
    }
    
    if (statusCounts.failure > 0) {
        return [
            icon: '‚ö†Ô∏è',
            title: 'Credential Validation Results',
            color: 'warning',
            mentionChannel: false
        ]
    }
    
    return [
        icon: '‚úÖ',
        title: 'Credential Validation Results',
        color: 'good',
        mentionChannel: false
    ]
}

def buildSlackMessage(Map config, Map statusCounts, String timestamp, String markdownTable) {
    def messageBuilder = new StringBuilder()
    
    if (config.mentionChannel) {
        messageBuilder.append('@here ')
    }
    
    messageBuilder.append("*${config.title}* ${config.icon}\n")
    messageBuilder.append("*Date:* ${timestamp}\n")
    
    if (statusCounts.success > 0 || statusCounts.failure > 0 || statusCounts.skipped > 0) {
        messageBuilder.append("*Status:* ")
        def statusParts = []
        
        if (statusCounts.success > 0) {
            statusParts.add("‚úÖ ${statusCounts.success} Successful")
        }
        if (statusCounts.failure > 0) {
            statusParts.add("‚ùå ${statusCounts.failure} Failed")
        }
        if (statusCounts.skipped > 0) {
            statusParts.add("‚è≠Ô∏è ${statusCounts.skipped} Skipped")
        }
        
        messageBuilder.append(statusParts.join(', '))
        messageBuilder.append('\n')
    }
    
    messageBuilder.append("<${env.BUILD_URL}|View Build>\n\n")
    messageBuilder.append(markdownTable)
    
    return messageBuilder.toString()
}

def createValidationTasks(Map pluginsMap, String pluginToValidate) {
    def tasks = [:]
    
    pluginsMap.each { pluginName, details ->
        // Filter based on user selection
        if (pluginToValidate == "ALL" || pluginToValidate == pluginName) {
            tasks[pluginName] = {
                validationResults[pluginName] = [
                    status: 'PENDING',
                    message: '',
                    timestamp: '',
                    displayName: details.displayName
                ]
                validatePluginCredentials(pluginName, details)
            }
        }
    }
    
    return tasks
}

def validatePluginCredentials(String pluginName, Map details) {
    def startTime = new Date().format('yyyy-MM-dd HH:mm:ss')
    
    stage("Validate ${details.displayName}") {
        // Check for skip conditions
        def skipReason = getSkipReason(details)
        if (skipReason) {
            recordSkippedValidation(pluginName, skipReason, startTime)
            return
        }
        
        // Run validation
        echo "Starting validation for ${pluginName}..."
        echo "Using validator type: ${details.validatorType}"
        
        def validator = getValidatorFunction(details.validatorType, details.customValidator)
        def result = validator(details.credFileId, pluginName, details)
        
        validationResults[pluginName].status = result.status
        validationResults[pluginName].message = result.message
        validationResults[pluginName].timestamp = startTime
        
        echo "Validation completed for ${pluginName}: ${result.status}"
    }
}

def getSkipReason(Map details) {
    if (!details.active) {
        return 'Validation not active yet'
    }
    
    def validatorType = details.validatorType
    if (!validatorType || validatorType.toLowerCase() in ['skip', 'none']) {
        return 'No validator configured yet'
    }
    
    return null
}

def recordSkippedValidation(String pluginName, String reason, String timestamp) {
    echo "Skipping ${pluginName} - ${reason}"
    validationResults[pluginName].status = 'SKIPPED'
    validationResults[pluginName].message = reason
    validationResults[pluginName].timestamp = timestamp
}

/**
 * Returns the appropriate validator function based on validatorType
 * Supports: jfrog, nexus, github, custom
 */
def getValidatorFunction(String validatorType, Closure customValidator = null) {
    def validatorMap = [
        'jfrog': this.&validateJFrogPlugin,
        'artifactory': this.&validateJFrogPlugin,
        'nexus': this.&validateGradlePlugin,
        'gradle': this.&validateGradlePlugin,
        'github': this.&validateGitHubActionsPlugin,
        'github-actions': this.&validateGitHubActionsPlugin
    ]
    
    def type = validatorType.toLowerCase()
    
    if (type == 'custom' && customValidator) {
        return customValidator
    }
    
    def validator = validatorMap[type]
    if (validator) {
        return validator
    }
    
    echo "WARNING: Unknown validator type '${validatorType}', falling back to JFrog validator"
    return this.&validateJFrogPlugin
}

// ============================================================================
// PLUGIN-SPECIFIC VALIDATORS
// Each plugin has its own validation strategy
// ============================================================================

/**
 * Validator for JFrog Artifactory plugins (Jenkins, Bamboo, TeamCity, Azure DevOps)
 * Uses JFrog CLI to test connection
 */
def validateJFrogPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "JFrog Artifactory Validator"
    def tempConfigName = "temp-${pluginName}-${UUID.randomUUID().toString().take(8)}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.url, var: 'SECRET_URL'],
                [password: creds.username, var: 'SECRET_USER'],
                [password: creds.password, var: 'SECRET_PASS']
            ]]) {
                echo "Testing JFrog Artifactory connection..."
                def configResult = 0
                withEnv([
                    "JFROG_URL=${creds.url}",
                    "JFROG_USER=${creds.username}",
                    "JFROG_PASSWORD=${creds.password}"
                ]) {
                    configResult = sh(
                        script: '''jf c add ''' + tempConfigName + ''' --url="${JFROG_URL}" --user="${JFROG_USER}" --password="${JFROG_PASSWORD}" --overwrite''',
                        returnStatus: true
                    )
                }
                
                if (configResult != 0) {
                    result.message = "Failed to configure JFrog CLI"
                    echo "ERROR: JFrog CLI configuration failed"
                    return result
                }
                
                sh "jf c use ${tempConfigName}"
                
                def pingResult = sh(
                    script: "jf rt ping",
                    returnStatus: true
                )
                
                if (pingResult == 0) {
                    result.status = 'SUCCESS'
                    result.message = 'Connection successful'
                    echo "SUCCESS: JFrog Artifactory connection successful"
                } else {
                    result.message = 'Connection failed'
                    echo "ERROR: JFrog Artifactory ping failed"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    } finally {
        try {
            sh "jf c rm ${tempConfigName} --quiet || true"
        } catch (Exception cleanupEx) {
            echo "Warning: Could not cleanup temp config"
        }
    }
    
    return result
}

/**
 * Validator for Gradle plugin
 * Uses Nexus REST API to test connection
 */
def validateGradlePlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "Gradle/Nexus Validator"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.url, var: 'SECRET_URL'],
                [password: creds.username, var: 'SECRET_USER'],
                [password: creds.password, var: 'SECRET_PASS']
            ]]) {
                echo "Testing Nexus connection via REST API..."
                def pingResult = nxPing(creds.url, creds.username, creds.password)
                
                if (pingResult.ok) {
                    result.status = 'SUCCESS'
                    result.message = pingResult.message ?: 'Connection successful'
                    echo "SUCCESS: Nexus connection successful"
                    echo "   ${pingResult.message}"
                    if (pingResult.username) {
                        echo "   Authenticated as: ${pingResult.username}"
                    }
                } else {
                    result.message = pingResult.message ?: 'Connection failed'
                    echo "ERROR: Nexus connection failed"
                    echo "   ${pingResult.message}"
                    if (pingResult.status) {
                        echo "   HTTP Status: ${pingResult.status}"
                    }
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

/**
 * Validator for GitHub Actions plugins
 * Three modes: trigger workflow, check run status, or test API connection
 * 
 * JSON format: { "secrets": { "token": "...", "url": "...", "workflow_run_url": "..." } }
 */
def validateGitHubActionsPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "GitHub Actions Validator"
    echo "   Plugin: ${pluginName}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = readJSON(text: readFile(file: env.CREDS_FILE))
            
            if (!creds.secrets?.token) {
                result.message = "Invalid JSON: missing token"
                echo "ERROR: Missing GitHub token in credential file"
                return result
            }
            
            def token = creds.secrets.token
            def workflowUrl = creds.secrets.url
            def workflowRunUrl = creds.secrets.workflow_run_url
            // Use branch from plugin config, then credential file, then default to 'main'
            def targetBranch = pluginDetails.githubBranch ?: creds.secrets.branch ?: 'main'
            
            echo "   Credential configuration:"
            echo "   - Token: ${token ? 'Present' : 'Missing'}"
            echo "   - Workflow URL: ${workflowUrl ? 'Present' : 'Missing'}"
            echo "   - Run URL: ${workflowRunUrl ? 'Present' : 'Missing'}"
            echo "   - Target branch: ${targetBranch}"
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[password: token, var: 'SECRET']]]) {
                if (workflowUrl && workflowRunUrl) {
                    echo "   Mode: Trigger and check workflow"
                    result = triggerAndCheckWorkflow(token, workflowUrl, workflowRunUrl, targetBranch)
                } else if (workflowRunUrl) {
                    echo "   Mode: Check workflow run status"
                    result = checkWorkflowRunStatus(token, workflowRunUrl)
                } else {
                    echo "   Mode: Test GitHub API connection only"
                    result = testGitHubApiConnection(token)
                }
            }
        }
    } catch (Exception e) {
        result.message = "Error: ${e.message}"
        echo "ERROR: GitHub Actions validation error: ${e.message}"
        e.printStackTrace()
    }
    
    return result
}

def triggerAndCheckWorkflow(String token, String workflowUrl, String workflowRunUrl, String targetBranch = 'main') {
    echo "Triggering GitHub Actions workflow..."
    echo "   Workflow URL: ${workflowUrl}"
    echo "   Target branch: ${targetBranch}"
    
    def triggerResult = ''
    withEnv([
        "GITHUB_TOKEN=${token}",
        "WORKFLOW_URL=${workflowUrl}",
        "TARGET_BRANCH=${targetBranch}"
    ]) {
        triggerResult = sh(
            script: '''
                curl -X POST -s -w '\\n%{http_code}' \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                "${WORKFLOW_URL}" \
                -d "{\\"ref\\":\\"${TARGET_BRANCH}\\"}" 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def lines = triggerResult.readLines()
    def statusCode = lines.last()
    def responseBody = lines.size() > 1 ? lines[0..-2].join('\n') : ''
    
    echo "   Response: HTTP ${statusCode}"
    if (responseBody && responseBody.trim()) {
        echo "   Response body: ${responseBody.take(300)}"
    }
    
    if (statusCode != "204") {
        echo "ERROR: Failed to trigger GitHub Actions workflow"
        return [status: 'FAILURE', message: "Failed to trigger workflow (HTTP ${statusCode})"]
    }
    
    echo "SUCCESS: Workflow triggered successfully (HTTP 204)"
    echo "   Waiting for workflow run to complete..."
    
    // Poll for workflow completion
    def maxAttempts = 60  // 5 minutes total (60 * 5 seconds)
    def attempt = 0
    def run = null
    
    while (attempt < maxAttempts) {
        sleep(5)
        attempt++
        
        def runStatusJson = ''
        withEnv([
            "GITHUB_TOKEN=${token}",
            "WORKFLOW_RUN_URL=${workflowRunUrl}"
        ]) {
            runStatusJson = sh(
                script: '''
                    curl -s -H 'Accept: application/vnd.github.v3+json' \
                    -H "Authorization: token ${GITHUB_TOKEN}" \
                    "${WORKFLOW_RUN_URL}?per_page=1"
                ''',
                returnStdout: true
            ).trim()
        }
        
        def runStatus = readJSON(text: runStatusJson)
        
        if (runStatus.workflow_runs && runStatus.workflow_runs.size() > 0) {
            run = runStatus.workflow_runs[0]
            
            echo "   Polling attempt ${attempt}/${maxAttempts}:"
            echo "   - Status: ${run.status}"
            echo "   - Conclusion: ${run.conclusion ?: 'pending'}"
            echo "   - Run ID: ${run.id}"
            echo "   - URL: ${run.html_url}"
            
            // Check if workflow has completed
            if (run.status == "completed") {
                echo "   Workflow completed!"
                
                if (run.conclusion == "success") {
                    echo "SUCCESS: GitHub Actions workflow completed successfully"
                    return [status: 'SUCCESS', message: "Workflow completed successfully"]
                } else if (run.conclusion == "failure") {
                    echo "ERROR: GitHub Actions workflow failed"
                    return [status: 'FAILURE', message: "Workflow failed with conclusion: ${run.conclusion}"]
                } else if (run.conclusion == "cancelled") {
                    echo "WARNING: GitHub Actions workflow was cancelled"
                    return [status: 'FAILURE', message: "Workflow cancelled"]
                } else {
                    echo "WARNING: GitHub Actions workflow completed with unexpected conclusion: ${run.conclusion}"
                    return [status: 'FAILURE', message: "Workflow completed with conclusion: ${run.conclusion}"]
                }
            }
            
            // Still in progress, continue polling
        } else {
            echo "   Polling attempt ${attempt}/${maxAttempts}: Workflow run not yet visible"
        }
    }
    
    // Timeout reached
    echo "ERROR: Timeout waiting for workflow to complete (waited ${maxAttempts * 5} seconds)"
    if (run) {
        echo "   Last known status: ${run.status}, conclusion: ${run.conclusion ?: 'pending'}"
        echo "   URL: ${run.html_url}"
    }
    return [status: 'FAILURE', message: "Timeout waiting for workflow completion"]
}

def checkWorkflowRunStatus(String token, String workflowRunUrl) {
    echo "Checking GitHub Actions workflow run status..."
    echo "   Run URL: ${workflowRunUrl}"
    
    def runJson = ''
    withEnv([
        "GITHUB_TOKEN=${token}",
        "WORKFLOW_RUN_URL=${workflowRunUrl}"
    ]) {
        runJson = sh(
            script: '''
                curl -s -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                "${WORKFLOW_RUN_URL}" 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def run = readJSON(text: runJson)
    
    if (!run.status) {
        echo "ERROR: Invalid response from GitHub API"
        echo "   Response may indicate an error or invalid run URL"
        return [status: 'FAILURE', message: "Failed to get workflow run status"]
    }
    
    echo "   Workflow run details:"
    echo "   - Status: ${run.status}"
    echo "   - Conclusion: ${run.conclusion ?: 'in_progress'}"
    echo "   - Run ID: ${run.id ?: 'N/A'}"
    echo "   - URL: ${run.html_url ?: 'N/A'}"
    
    if (run.conclusion == "success") {
        echo "SUCCESS: GitHub Actions workflow run successful"
        return [status: 'SUCCESS', message: "Workflow run succeeded"]
    }
    
    if (run.status == "completed" && run.conclusion == "failure") {
        echo "ERROR: GitHub Actions workflow run failed"
        return [status: 'FAILURE', message: "Workflow run failed"]
    }
    
    echo "SUCCESS: GitHub Actions accessible, workflow is ${run.status}"
    return [status: 'SUCCESS', message: "Workflow status: ${run.status}, conclusion: ${run.conclusion ?: 'pending'}"]
}

def testGitHubApiConnection(String token) {
    echo "Testing GitHub API connection..."
    echo "   Endpoint: https://api.github.com/user"
    
    def userJson = ''
    withEnv(["GITHUB_TOKEN=${token}"]) {
        userJson = sh(
            script: '''
                curl -s -w '\\n%{http_code}' \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                'https://api.github.com/user' 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def lines = userJson.readLines()
    def statusCode = lines.last()
    
    echo "   Response: HTTP ${statusCode}"
    
    if (statusCode == "200") {
        def user = readJSON(text: lines[0..-2].join('\n'))
        echo "SUCCESS: GitHub API connection successful"
        echo "   - Authenticated as: ${user.login}"
        echo "   - Account type: ${user.type ?: 'N/A'}"
        return [status: 'SUCCESS', message: "GitHub API connected as ${user.login}"]
    }
    
    echo "ERROR: GitHub API authentication failed"
    if (statusCode == "401") {
        echo "   Token is invalid or expired"
    }
    return [status: 'FAILURE', message: "GitHub API authentication failed (HTTP ${statusCode})"]
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Parses and validates credentials JSON file
 * Returns: [ok: boolean, username: string, password: string, url: string, message: string]
 */
def parseCredentialsFile(String filePath, String pluginName) {
    try {
        def creds = readJSON(text: readFile(file: filePath))
        
        if (!creds.secrets) {
            echo "ERROR: Invalid JSON: missing 'secrets' key"
            return [ok: false, message: "Invalid JSON: missing 'secrets' key"]
        }
        
        def secrets = creds.secrets
        def missingFields = []
        
        if (!secrets.username) missingFields.add('username')
        if (!secrets.password) missingFields.add('password')
        if (!secrets.url) missingFields.add('url')
        
        if (missingFields) {
            echo "ERROR: Missing required fields: ${missingFields.join(', ')}"
            return [ok: false, message: "Missing required fields: ${missingFields.join(', ')}"]
        }
        
        echo "Credentials parsed successfully"
        return [ok: true, username: secrets.username, password: secrets.password, url: secrets.url]
    } catch (Exception e) {
        echo "ERROR: Failed to parse credentials: ${e.message}"
        return [ok: false, message: "Failed to parse JSON: ${e.message}"]
    }
}

/**
 * Handles credential-related errors with helpful troubleshooting info
 */
def handleCredentialError(Exception e, String credFileId, String pluginName) {
    def errorMsg = e.message
    
    echo "ERROR: Credential error:"
    echo "   Message: ${errorMsg}"
    echo "   Credential ID: '${credFileId}'"
    
    def isCredentialNotFound = errorMsg?.toLowerCase()?.contains("not found") || 
                               errorMsg?.contains("CredentialNotFoundException")
    
    if (isCredentialNotFound) {
        echo "   Hint: Create secret file credential with ID '${credFileId}'"
        return "Credentials not configured yet"
    }
    
    return "Error: ${errorMsg?.take(50) ?: 'Unknown error'}"
}

def formatValidationResultsForJenkins(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "Plugin", "Status", "Message", "Timestamp"))
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "-" * 30, "-" * 10, "-" * 40, "-" * 19))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)
        def message = data.message ?: 'N/A'
        def timestamp = data.timestamp ?: 'N/A'

        table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
            displayName, status, message, timestamp))
    }

    table.append("```")
    return table.toString()
}

def formatValidationResultsForSlack(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s\n", "Plugin", "Status"))
    table.append(String.format("%-30s | %-10s\n", "-" * 30, "-" * 10))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)

        table.append(String.format("%-30s | %-10s\n", displayName, status))
    }

    table.append("```")
    return table.toString()
}

def getStatusEmoji(String status) {
    switch(status) {
        case 'SUCCESS': return '‚úÖ'
        case 'FAILURE': return '‚ùå'
        case 'SKIPPED': return '‚è≠Ô∏è'
        default: return status ?: 'N/A'
    }
}

/**
 * Installs JFrog CLI using official installer script
 */
def installJfrogCli() {
    def downloadStatus = sh(
        script: 'curl -fL https://install-cli.jfrog.io | sh',
        returnStatus: true
    )
    
    if (downloadStatus != 0) {
        error "Failed to download JFrog CLI (exit code: ${downloadStatus})"
    }
    
    def verifyStatus = sh(script: 'jf --version', returnStatus: true)
    
    if (verifyStatus != 0) {
        error "Failed to verify JFrog CLI installation (exit code: ${verifyStatus})"
    }
    
    echo "JFrog CLI installed successfully"
}

/**
 * Tests Nexus Repository connection using /service/local/status endpoint
 * Returns: [ok: boolean, message: string, username: string, status: int]
 * Uses shell commands to avoid Jenkins sandbox restrictions
 */
def nxPing(String nexusUrl, String username, String password) {
    try {
        def endpoint = "${nexusUrl}/service/local/status"
        
        // Use HEAD request (-I) which is lighter and sufficient for authentication check
        def response = ''
        withEnv([
            "NEXUS_USER=${username}",
            "NEXUS_PASSWORD=${password}",
            "NEXUS_ENDPOINT=${endpoint}"
        ]) {
            response = sh(
                script: '''
                    curl -s -I -w '\\n%{http_code}' \
                    --user "${NEXUS_USER}:${NEXUS_PASSWORD}" \
                    -H 'Accept: application/json' \
                    --connect-timeout 5 \
                    --max-time 10 \
                    "${NEXUS_ENDPOINT}" 2>&1
                ''',
                returnStdout: true
            ).trim()
        }
        
        def lines = response.readLines()
        def statusCode = lines.last() as Integer
        
        // Success - credentials are valid
        if (statusCode == 200 || statusCode == 204) {
            echo "SUCCESS: Nexus Repository connection successful"
            return [ok: true, message: "Credentials valid (${statusCode} OK)", username: username, status: statusCode]
        }
        
        // Authentication failed
        if (statusCode == 401) {
            return [ok: false, message: "Unauthorized (401) ‚Äî Invalid username/password", status: 401]
        }
        
        // Permission denied
        if (statusCode == 403) {
            return [ok: false, message: "Forbidden (403) ‚Äî Valid credentials but insufficient permissions", status: 403]
        }
        
        // Endpoint not supported or other error
        return [ok: false, message: "Endpoint not supported (${statusCode})", status: statusCode]

    } catch (Exception e) {
        return [ok: false, message: "Connection error: ${e.message}", status: -1]
    }
}
