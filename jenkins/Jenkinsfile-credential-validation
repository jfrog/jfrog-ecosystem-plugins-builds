// Jenkins CI pipeline for validating JFrog Artifactory credentials across multiple ecosystem plugins.
// Runs nightly to ensure credentials are properly configured and functional.
// Notifies Slack with validation results in markdown table format.

node("docker-ubuntu20-xlarge") {
    properties([
        parameters([
            string(
                name: 'SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION',
                defaultValue: 'jfrog-ecosystem-plugins-notifications',
                description: 'Slack channel for credential validation notifications'
            ),
            choice(
                name: 'PLUGIN_TO_VALIDATE',
                choices: ['ALL', 'jenkins-jfrog-plugin', 'gradle-jfrog-plugin', 'bamboo-jfrog-plugin', 'teamcity-jfrog-plugin', 'azure-devops-extension', 'artifactory-maven-plugin'],
                description: 'Select specific plugin to validate or ALL for all plugins'
            )
        ]),
        pipelineTriggers([
            cron('0 1 * * *')
        ])
    ])
    
    try {
        validationResults = [:]
        buildStatus = 'SUCCESS'
        cliExecutableName = 'jf'
        formattedDate = new Date().format('yyyy-MM-dd HH:mm:ss')
        env.JFROG_CLI_LOG_LEVEL = "ERROR"  // Minimize logging for security
        slackChannelName = params.SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION
        pluginToValidate = params.PLUGIN_TO_VALIDATE
        
        // Debug: Log the actual parameter value being used
        echo "üì¢ Slack Channel Parameter: '${slackChannelName}'"
        echo "   (Note: To change this, update the parameter in Jenkins UI: Job ‚Üí Configure ‚Üí Parameters)"
        
        // ============================================================================
        // PLUGIN REGISTRY - Add your plugins here (Plug & Play)
        // ============================================================================
        // Just add an entry with credFileId, displayName, and validatorType
        // The system will automatically handle the rest!
        //
        // validatorType options:
        //   - "jfrog"   : Uses JFrog CLI
        //   - "nexus"   : Uses Nexus REST API (for Gradle)
        //   - "github"  : Uses GitHub API to trigger/check workflows
        //   - "teamcity": Uses TeamCity REST API
        //   - "azure-devops": Uses Azure DevOps Marketplace API
        //   - "custom"  : Uses custom validator function (provide customValidator)
        //   - "skip"    : Skip validation (or omit validatorType entirely)
        //
        // If validatorType is not specified or set to "skip", the plugin will be SKIPPED
        // ============================================================================
        
        def pluginsMap = [
            "jenkins-jfrog-plugin": [
                credFileId: "jenkins-jfrog-creds",
                displayName: "Jenkins JFrog Plugin",
                active: true,
                validatorType: "jfrog"
            ],
            "gradle-jfrog-plugin": [
                credFileId: "gradle-plugin-creds-json",
                displayName: "Gradle JFrog Plugin",
                active: true,
                validatorType: "nexus"
            ],
            "bamboo-jfrog-plugin": [
                credFileId: "bamboo-plugin-creds-json",
                displayName: "Bamboo JFrog Plugin",
                active: false,
                validatorType: "jfrog"
            ],
            "teamcity-jfrog-plugin": [
                credFileId: "teamcity-plugin-creds-json",
                displayName: "TeamCity JFrog Plugin",
                active: true,
                validatorType: "teamcity"
            ],
            "azure-devops-extension": [
                credFileId: "azure-devops-plugin-creds-json",
                displayName: "Azure DevOps Extension",
                active: true,
                validatorType: "azure-devops"
            ],
            "artifactory-maven-plugin": [
                credFileId: "artifactory-maven-plugin-github-creds",
                displayName: "Artifactory Maven Plugin",
                active: true,
                validatorType: "github",
                githubBranch: "master"
            ]
            
            // ========================================
            // TO ADD A NEW PLUGIN - Just copy this template:
            // ========================================
            // ,"my-new-plugin": [
            //     credFileId: "my-plugin-creds",
            //     displayName: "My New Plugin",
            //     active: false,
            //     validatorType: "skip"  // Options: "jfrog", "nexus", "github", "custom", "skip"
            //                            // Leave as "skip" or omit validatorType to skip validation
            // ]
        ]
        
        dir('credential-validation-temp') {
            stage('Initial Setup') {
                try {
                    script {
                        installJfrogCli()
                        echo "JFrog CLI installed successfully"
                    }
                } catch (e) {
                    echo "Error during initial setup: ${e}"
                    throw e
                }
            }
            
            script {
                def tasksToRun = createValidationTasks(pluginsMap, pluginToValidate)
                parallel(tasksToRun)
            }
        }
    } catch (e) {
        echo "ERROR: Pipeline failed with exception: ${e}"
        buildStatus = 'FAILURE'
        throw e
    } finally {
        stage('Send Notifications') {
            sendSlackNotification(validationResults, buildStatus, slackChannelName, formattedDate)
        }
    }
}

def sendSlackNotification(Map validationResults, String buildStatus, String channelName, String timestamp) {
    def statusCounts = calculateStatusCounts(validationResults)
    def notificationConfig = determineNotificationConfig(buildStatus, statusCounts)
    
    // Print detailed results to Jenkins console
    def detailedTable = formatValidationResultsForJenkins(validationResults)
    echo "=" * 80
    echo "VALIDATION RESULTS"
    echo "=" * 80
    echo detailedTable
    echo "=" * 80
    
    // Create compact message for Slack
    def slackTable = formatValidationResultsForSlack(validationResults)
    def message = buildSlackMessage(notificationConfig, statusCounts, timestamp, slackTable)
    
    // Try to send Slack notification
    try {
        if (channelName && channelName.trim() != '') {
            slackSend(
                channel: "#${channelName}",
                message: message,
                color: notificationConfig.color
            )
            echo "SUCCESS: Slack notification sent to #${channelName}"
        } else {
            echo "WARNING: Slack notification skipped: No channel name configured"
        }
    } catch (Exception slackEx) {
        echo "WARNING: Slack notification failed (non-critical): ${slackEx.message}"
        echo "   Results are printed above."
    }
}

def calculateStatusCounts(Map validationResults) {
    return [
        success: validationResults.count { k, v -> v.status == 'SUCCESS' },
        failure: validationResults.count { k, v -> v.status == 'FAILURE' },
        skipped: validationResults.count { k, v -> v.status == 'SKIPPED' }
    ]
}

def determineNotificationConfig(String buildStatus, Map statusCounts) {
    if (buildStatus != 'SUCCESS') {
        return [
            icon: '‚ùå',
            title: 'Credential Validation Pipeline Failed',
            color: 'danger',
            mentionChannel: true
        ]
    }
    
    if (statusCounts.failure > 0) {
        return [
            icon: '‚ö†Ô∏è',
            title: 'Credential Validation Results',
            color: 'warning',
            mentionChannel: false
        ]
    }
    
    return [
        icon: '‚úÖ',
        title: 'Credential Validation Results',
        color: 'good',
        mentionChannel: false
    ]
}

def buildSlackMessage(Map config, Map statusCounts, String timestamp, String markdownTable) {
    def messageBuilder = new StringBuilder()
    
    if (config.mentionChannel) {
        messageBuilder.append('@here ')
    }
    
    messageBuilder.append("*${config.title}* ${config.icon}\n")
    messageBuilder.append("*Date:* ${timestamp}\n")
    
    if (statusCounts.success > 0 || statusCounts.failure > 0 || statusCounts.skipped > 0) {
        messageBuilder.append("*Status:* ")
        def statusParts = []
        
        if (statusCounts.success > 0) {
            statusParts.add("‚úÖ ${statusCounts.success} Successful")
        }
        if (statusCounts.failure > 0) {
            statusParts.add("‚ùå ${statusCounts.failure} Failed")
        }
        if (statusCounts.skipped > 0) {
            statusParts.add("‚è≠Ô∏è ${statusCounts.skipped} Skipped")
        }
        
        messageBuilder.append(statusParts.join(', '))
        messageBuilder.append('\n')
    }
    
    messageBuilder.append("<${env.BUILD_URL}|View Build>\n\n")
    messageBuilder.append(markdownTable)
    
    return messageBuilder.toString()
}

def createValidationTasks(Map pluginsMap, String pluginToValidate) {
    def tasks = [:]
    
    pluginsMap.each { pluginName, details ->
        // Filter based on user selection
        if (pluginToValidate == "ALL" || pluginToValidate == pluginName) {
            tasks[pluginName] = {
                validationResults[pluginName] = [
                    status: 'PENDING',
                    message: '',
                    timestamp: '',
                    displayName: details.displayName
                ]
                validatePluginCredentials(pluginName, details)
            }
        }
    }
    
    return tasks
}

def validatePluginCredentials(String pluginName, Map details) {
    def startTime = new Date().format('yyyy-MM-dd HH:mm:ss')
    
    stage("Validate ${details.displayName}") {
        // Check for skip conditions
        def skipReason = getSkipReason(details)
        if (skipReason) {
            recordSkippedValidation(pluginName, skipReason, startTime)
            return
        }
        
        // Run validation
        echo "Starting validation for ${pluginName}..."
        echo "Using validator type: ${details.validatorType}"
        
        def validator = getValidatorFunction(details.validatorType, details.customValidator)
        def result = validator(details.credFileId, pluginName, details)
        
        validationResults[pluginName].status = result.status
        validationResults[pluginName].message = result.message
        validationResults[pluginName].timestamp = startTime
        
        echo "Validation completed for ${pluginName}: ${result.status}"
    }
}

def getSkipReason(Map details) {
    if (!details.active) {
        return 'Validation not active yet'
    }
    
    def validatorType = details.validatorType
    if (!validatorType || validatorType.toLowerCase() in ['skip', 'none']) {
        return 'No validator configured yet'
    }
    
    return null
}

def recordSkippedValidation(String pluginName, String reason, String timestamp) {
    echo "Skipping ${pluginName} - ${reason}"
    validationResults[pluginName].status = 'SKIPPED'
    validationResults[pluginName].message = reason
    validationResults[pluginName].timestamp = timestamp
}

/**
 * Returns the appropriate validator function based on validatorType
 * Supports: jfrog, nexus, github, azure-devops, teamcity, custom
 */
def getValidatorFunction(String validatorType, Closure customValidator = null) {
    def validatorMap = [
        'jfrog': this.&validateJFrogPlugin,
        'artifactory': this.&validateJFrogPlugin,
        'nexus': this.&validateGradlePlugin,
        'gradle': this.&validateGradlePlugin,
        'github': this.&validateGitHubActionsPlugin,
        'github-actions': this.&validateGitHubActionsPlugin,
        'azure-devops': this.&checkAdoMarketplaceAuth,
        'teamcity': this.&validateTeamCityPlugin
    ]
    
    def type = validatorType.toLowerCase()
    
    if (type == 'custom' && customValidator) {
        return customValidator
    }
    
    def validator = validatorMap[type]
    if (validator) {
        return validator
    }
    
    echo "WARNING: Unknown validator type '${validatorType}', falling back to JFrog validator"
    return this.&validateJFrogPlugin
}

// ============================================================================
// PLUGIN-SPECIFIC VALIDATORS
// Each plugin has its own validation strategy
// ============================================================================

/**
 * Validator for JFrog Artifactory plugins (Jenkins, Bamboo, TeamCity, Azure DevOps)
 * Uses JFrog CLI to test connection
 */
def validateJFrogPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "JFrog Artifactory Validator"
    def tempConfigName = "temp-${pluginName}-${UUID.randomUUID().toString().take(8)}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.url, var: 'SECRET_URL'],
                [password: creds.username, var: 'SECRET_USER'],
                [password: creds.password, var: 'SECRET_PASS']
            ]]) {
                echo "Testing JFrog Artifactory connection..."
                def configResult = 0
                withEnv([
                    "JFROG_URL=${creds.url}",
                    "JFROG_USER=${creds.username}",
                    "JFROG_PASSWORD=${creds.password}"
                ]) {
                    configResult = sh(
                        script: '''jf c add ''' + tempConfigName + ''' --url="${JFROG_URL}" --user="${JFROG_USER}" --password="${JFROG_PASSWORD}" --overwrite''',
                        returnStatus: true
                    )
                }
                
                if (configResult != 0) {
                    result.message = "Failed to configure JFrog CLI"
                    echo "ERROR: JFrog CLI configuration failed"
                    return result
                }
                
                sh "jf c use ${tempConfigName}"
                
                def pingResult = sh(
                    script: "jf rt ping",
                    returnStatus: true
                )
                
                if (pingResult == 0) {
                    result.status = 'SUCCESS'
                    result.message = 'Connection successful'
                    echo "SUCCESS: JFrog Artifactory connection successful"
                } else {
                    result.message = 'Connection failed'
                    echo "ERROR: JFrog Artifactory ping failed"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    } finally {
        try {
            sh "jf c rm ${tempConfigName} --quiet || true"
        } catch (Exception cleanupEx) {
            echo "Warning: Could not cleanup temp config"
        }
    }
    
    return result
}

/**
 * Validator for Gradle plugin
 * Uses Nexus REST API to test connection
 */
def validateGradlePlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "Gradle/Nexus Validator"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.url, var: 'SECRET_URL'],
                [password: creds.username, var: 'SECRET_USER'],
                [password: creds.password, var: 'SECRET_PASS']
            ]]) {
                echo "Testing Nexus connection via REST API..."
                def pingResult = nxPing(creds.url, creds.username, creds.password)
                
                if (pingResult.ok) {
                    result.status = 'SUCCESS'
                    result.message = pingResult.message ?: 'Connection successful'
                    echo "SUCCESS: Nexus connection successful"
                    echo "   ${pingResult.message}"
                    if (pingResult.username) {
                        echo "   Authenticated as: ${pingResult.username}"
                    }
                } else {
                    result.message = pingResult.message ?: 'Connection failed'
                    echo "ERROR: Nexus connection failed"
                    echo "   ${pingResult.message}"
                    if (pingResult.status) {
                        echo "   HTTP Status: ${pingResult.status}"
                    }
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

/**
 * Validator for TeamCity plugin
 * Uses JetBrains Plugin Repository REST API to validate token credentials
 * Validates that the token can authenticate and access vendor information
 */
def validateTeamCityPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "TeamCity Validator (JetBrains Plugin Repository)"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = parseTeamCityCredentialsFile(env.CREDS_FILE, pluginName)
            if (!creds.ok) {
                result.message = creds.message
                return result
            }
            
            // Wrap operations with password masking
            // Mask both the token variable and the environment variable used by the script
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [
                [password: creds.token, var: 'SECRET_TOKEN'],
                [password: creds.token, var: 'JETBRAINS_PLUGIN_TOKEN'],
                [password: creds.url ?: '', var: 'SECRET_URL']
            ]]) {
                echo "Testing JetBrains Plugin Repository connection..."
                def validationResult = validateJetBrainsPluginRepository(creds.token, creds.url)
                
                if (validationResult.ok) {
                    result.status = 'SUCCESS'
                    result.message = validationResult.message ?: 'Connection successful'
                    echo "SUCCESS: JetBrains Plugin Repository connection successful"
                    echo "   ${validationResult.message}"
                    if (validationResult.vendorName) {
                        echo "   Vendor: ${validationResult.vendorName}"
                    }
                    if (validationResult.vendorUrl) {
                        echo "   Vendor URL: ${validationResult.vendorUrl}"
                    }
                } else {
                    result.message = validationResult.message ?: 'Connection failed'
                    echo "ERROR: JetBrains Plugin Repository connection failed"
                    echo "   ${validationResult.message}"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

/**
 * Validator for GitHub Actions plugins
 * Three modes: trigger workflow, check run status, or test API connection
 * 
 * JSON format: { "secrets": { "token": "...", "url": "...", "workflow_run_url": "..." } }
 */
def validateGitHubActionsPlugin(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "GitHub Actions Validator"
    echo "   Plugin: ${pluginName}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = readJSON(text: readFile(file: env.CREDS_FILE))
            
            if (!creds.secrets?.token) {
                result.message = "Invalid JSON: missing token"
                echo "ERROR: Missing GitHub token in credential file"
                return result
            }
            
            def token = creds.secrets.token
            def workflowUrl = creds.secrets.url
            def workflowRunUrl = creds.secrets.workflow_run_url
            // Use branch from plugin config, then credential file, then default to 'main'
            def targetBranch = pluginDetails.githubBranch ?: creds.secrets.branch ?: 'main'
            
            echo "   Credential configuration:"
            echo "   - Token: ${token ? 'Present' : 'Missing'}"
            echo "   - Workflow URL: ${workflowUrl ? 'Present' : 'Missing'}"
            echo "   - Run URL: ${workflowRunUrl ? 'Present' : 'Missing'}"
            echo "   - Target branch: ${targetBranch}"
            
            // Wrap operations with password masking
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[password: token, var: 'SECRET']]]) {
                if (workflowUrl && workflowRunUrl) {
                    echo "   Mode: Trigger and check workflow"
                    result = triggerAndCheckWorkflow(token, workflowUrl, workflowRunUrl, targetBranch)
                } else if (workflowRunUrl) {
                    echo "   Mode: Check workflow run status"
                    result = checkWorkflowRunStatus(token, workflowRunUrl)
                } else {
                    echo "   Mode: Test GitHub API connection only"
                    result = testGitHubApiConnection(token)
                }
            }
        }
    } catch (Exception e) {
        result.message = "Error: ${e.message}"
        echo "ERROR: GitHub Actions validation error: ${e.message}"
        e.printStackTrace()
    }
    
    return result
}

def triggerAndCheckWorkflow(String token, String workflowUrl, String workflowRunUrl, String targetBranch = 'main') {
    echo "Triggering GitHub Actions workflow..."
    echo "   Workflow URL: ${workflowUrl}"
    echo "   Target branch: ${targetBranch}"
    
    def triggerResult = ''
    withEnv([
        "GITHUB_TOKEN=${token}",
        "WORKFLOW_URL=${workflowUrl}",
        "TARGET_BRANCH=${targetBranch}"
    ]) {
        triggerResult = sh(
            script: '''
                curl -X POST -s -w '\\n%{http_code}' \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                "${WORKFLOW_URL}" \
                -d "{\\"ref\\":\\"${TARGET_BRANCH}\\"}" 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def lines = triggerResult.readLines()
    def statusCode = lines.last()
    def responseBody = lines.size() > 1 ? lines[0..-2].join('\n') : ''
    
    echo "   Response: HTTP ${statusCode}"
    if (responseBody && responseBody.trim()) {
        echo "   Response body: ${responseBody.take(300)}"
    }
    
    if (statusCode != "204") {
        echo "ERROR: Failed to trigger GitHub Actions workflow"
        return [status: 'FAILURE', message: "Failed to trigger workflow (HTTP ${statusCode})"]
    }
    
    echo "SUCCESS: Workflow triggered successfully (HTTP 204)"
    echo "   Waiting for workflow run to complete..."
    
    // Poll for workflow completion
    def maxAttempts = 60  // 5 minutes total (60 * 5 seconds)
    def attempt = 0
    def run = null
    
    while (attempt < maxAttempts) {
        sleep(5)
        attempt++
        
        def runStatusJson = ''
        withEnv([
            "GITHUB_TOKEN=${token}",
            "WORKFLOW_RUN_URL=${workflowRunUrl}"
        ]) {
            runStatusJson = sh(
                script: '''
                    curl -s -H 'Accept: application/vnd.github.v3+json' \
                    -H "Authorization: token ${GITHUB_TOKEN}" \
                    "${WORKFLOW_RUN_URL}?per_page=1"
                ''',
                returnStdout: true
            ).trim()
        }
        
        def runStatus = readJSON(text: runStatusJson)
        
        if (runStatus.workflow_runs && runStatus.workflow_runs.size() > 0) {
            run = runStatus.workflow_runs[0]
            
            echo "   Polling attempt ${attempt}/${maxAttempts}:"
            echo "   - Status: ${run.status}"
            echo "   - Conclusion: ${run.conclusion ?: 'pending'}"
            echo "   - Run ID: ${run.id}"
            echo "   - URL: ${run.html_url}"
            
            // Check if workflow has completed
            if (run.status == "completed") {
                echo "   Workflow completed!"
                
                if (run.conclusion == "success") {
                    echo "SUCCESS: GitHub Actions workflow completed successfully"
                    return [status: 'SUCCESS', message: "Workflow completed successfully"]
                } else if (run.conclusion == "failure") {
                    echo "ERROR: GitHub Actions workflow failed"
                    return [status: 'FAILURE', message: "Workflow failed with conclusion: ${run.conclusion}"]
                } else if (run.conclusion == "cancelled") {
                    echo "WARNING: GitHub Actions workflow was cancelled"
                    return [status: 'FAILURE', message: "Workflow cancelled"]
                } else {
                    echo "WARNING: GitHub Actions workflow completed with unexpected conclusion: ${run.conclusion}"
                    return [status: 'FAILURE', message: "Workflow completed with conclusion: ${run.conclusion}"]
                }
            }
            
            // Still in progress, continue polling
        } else {
            echo "   Polling attempt ${attempt}/${maxAttempts}: Workflow run not yet visible"
        }
    }
    
    // Timeout reached
    echo "ERROR: Timeout waiting for workflow to complete (waited ${maxAttempts * 5} seconds)"
    if (run) {
        echo "   Last known status: ${run.status}, conclusion: ${run.conclusion ?: 'pending'}"
        echo "   URL: ${run.html_url}"
    }
    return [status: 'FAILURE', message: "Timeout waiting for workflow completion"]
}

def checkWorkflowRunStatus(String token, String workflowRunUrl) {
    echo "Checking GitHub Actions workflow run status..."
    echo "   Run URL: ${workflowRunUrl}"
    
    def runJson = ''
    withEnv([
        "GITHUB_TOKEN=${token}",
        "WORKFLOW_RUN_URL=${workflowRunUrl}"
    ]) {
        runJson = sh(
            script: '''
                curl -s -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                "${WORKFLOW_RUN_URL}" 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def run = readJSON(text: runJson)
    
    if (!run.status) {
        echo "ERROR: Invalid response from GitHub API"
        echo "   Response may indicate an error or invalid run URL"
        return [status: 'FAILURE', message: "Failed to get workflow run status"]
    }
    
    echo "   Workflow run details:"
    echo "   - Status: ${run.status}"
    echo "   - Conclusion: ${run.conclusion ?: 'in_progress'}"
    echo "   - Run ID: ${run.id ?: 'N/A'}"
    echo "   - URL: ${run.html_url ?: 'N/A'}"
    
    if (run.conclusion == "success") {
        echo "SUCCESS: GitHub Actions workflow run successful"
        return [status: 'SUCCESS', message: "Workflow run succeeded"]
    }
    
    if (run.status == "completed" && run.conclusion == "failure") {
        echo "ERROR: GitHub Actions workflow run failed"
        return [status: 'FAILURE', message: "Workflow run failed"]
    }
    
    echo "SUCCESS: GitHub Actions accessible, workflow is ${run.status}"
    return [status: 'SUCCESS', message: "Workflow status: ${run.status}, conclusion: ${run.conclusion ?: 'pending'}"]
}

def testGitHubApiConnection(String token) {
    echo "Testing GitHub API connection..."
    echo "   Endpoint: https://api.github.com/user"
    
    def userJson = ''
    withEnv(["GITHUB_TOKEN=${token}"]) {
        userJson = sh(
            script: '''
                curl -s -w '\\n%{http_code}' \
                -H 'Accept: application/vnd.github.v3+json' \
                -H "Authorization: token ${GITHUB_TOKEN}" \
                'https://api.github.com/user' 2>&1
            ''',
            returnStdout: true
        ).trim()
    }
    
    def lines = userJson.readLines()
    def statusCode = lines.last()
    
    echo "   Response: HTTP ${statusCode}"
    
    if (statusCode == "200") {
        def user = readJSON(text: lines[0..-2].join('\n'))
        echo "SUCCESS: GitHub API connection successful"
        echo "   - Authenticated as: ${user.login}"
        echo "   - Account type: ${user.type ?: 'N/A'}"
        return [status: 'SUCCESS', message: "GitHub API connected as ${user.login}"]
    }
    
    echo "ERROR: GitHub API authentication failed"
    if (statusCode == "401") {
        echo "   Token is invalid or expired"
    }
    return [status: 'FAILURE', message: "GitHub API authentication failed (HTTP ${statusCode})"]
}

/**
 * Validator for Azure DevOps Extension Marketplace
 * Uses tfx CLI to validate Personal Access Token (PAT) for Azure DevOps Marketplace
 * 
 * JSON format: { "secrets": { "token": "...", "publisherId": "...", "extensionId": "..." } }
 */
def checkAdoMarketplaceAuth(String credFileId, String pluginName, Map pluginDetails = [:]) {
    echo "üîß Azure DevOps Marketplace Validator"
    def result = [status: 'FAILURE', message: '']
    
    try {
        withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
            def creds = readJSON(text: readFile(file: env.CREDS_FILE))
            
            if (!creds.secrets?.token) {
                result.message = "Invalid JSON: missing token"
                echo "‚ùå Missing Azure DevOps Personal Access Token"
                return result
            }
            
            def token = creds.secrets.token
            def publisherId = creds.secrets.publisherId
            def extensionId = creds.secrets.extensionId
            
            if (!publisherId) {
                result.message = "Invalid JSON: missing publisherId"
                echo "‚ùå Missing publisherId"
                return result
            }
            
            if (!extensionId) {
                result.message = "Invalid JSON: missing extensionId"
                echo "‚ùå Missing extensionId"
                return result
            }
            
            echo "Testing Azure DevOps Marketplace authentication..."
            
            // Install tfx-cli if not already available (only for Azure DevOps validation)
            try {
                installTfxCli()
            } catch (Exception installEx) {
                result.message = "Failed to install tfx-cli: ${installEx.message}"
                echo "‚ùå Azure DevOps Marketplace validation failed: Could not install tfx-cli"
                echo "   Error: ${installEx.message}"
                return result
            }
            
            // Use withEnv to securely pass token as environment variable
            // Wrap with password masking to prevent credentials from appearing in console logs
            def tfxResult = ''
            wrap([$class: 'MaskPasswordsBuildWrapper', varPasswordPairs: [[password: token, var: 'AZURE_DEVOPS_TOKEN']]]) {
                withEnv([
                    "AZURE_DEVOPS_TOKEN=${token}",
                    "PUBLISHER_ID=${publisherId}",
                    "EXTENSION_ID=${extensionId}"
                ]) {
                    // Run tfx and capture both output and exit code
                    // Use set +x to prevent command echoing (which could expose credentials)
                    tfxResult = sh(
                        script: '''
                            set +x
                            OUTPUT=$(tfx extension show \
                                --publisher "${PUBLISHER_ID}" \
                                --extension-id "${EXTENSION_ID}" \
                                -t "${AZURE_DEVOPS_TOKEN}" \
                                --service-url https://marketplace.visualstudio.com \
                                --no-prompt \
                                --json 2>&1)
                            EXIT_CODE=$?
                            echo "${OUTPUT}"
                            echo "EXIT_CODE:${EXIT_CODE}"
                        ''',
                        returnStdout: true
                    ).trim()
                }
            }
            
            // Parse output and exit code
            def lines = tfxResult.readLines()
            def tfxExitCode = 1  // Default to failure for safety
            def tfxOutput = ''
            
            if (lines.size() > 0 && lines.last().startsWith("EXIT_CODE:")) {
                tfxExitCode = (lines.last().split(":")[1] as Integer)
                tfxOutput = lines[0..-2].join('\n').trim()
            } else {
                // Fallback: assume failure if we can't parse exit code
                // This is safer than assuming success - if parsing fails, something went wrong
                tfxOutput = tfxResult
                tfxExitCode = 1
                echo "‚ö†Ô∏è Warning: Could not parse exit code from tfx output, assuming failure"
            }
            
            // Check for specific authentication error message from tfx
            // tfx outputs: "error: Received response 401 (Not Authorized). Check that your personal access token is correct and hasn't expired."
            def authErrorMsg = "Received response 401 (Not Authorized). Check that your personal access token is correct and hasn't expired."
            def hasAuthError = tfxOutput.contains("error:") && tfxOutput.contains(authErrorMsg)
            
            // Validate that tfx produced meaningful output (JSON format expected with --json flag)
            def hasValidOutput = tfxOutput && tfxOutput.trim().length() > 0 && (tfxOutput.trim().startsWith("{") || tfxOutput.trim().startsWith("["))
            
            if (tfxExitCode == 0 && !hasAuthError && !tfxOutput.toLowerCase().contains("error:") && hasValidOutput) {
                result.status = 'SUCCESS'
                result.message = "Marketplace authentication successful"
                echo "‚úÖ Azure DevOps Marketplace authentication successful"
                echo "   Publisher: ${publisherId}"
                echo "   Extension: ${extensionId}"
            } else {
                def errorMsg = tfxOutput ?: "Unknown error (exit code: ${tfxExitCode})"
                
                // Note: Exit code 127 check removed as unreachable - installTfxCli() verifies installation
                // and throws exception if tfx is not available, which is caught by try-catch above
                
                if (!hasValidOutput && tfxExitCode == 0) {
                    // Check for empty or invalid output first
                    result.message = "Validation failed: No meaningful output from tfx (expected JSON response)"
                    echo "‚ùå Azure DevOps Marketplace validation failed: tfx returned success but produced no output"
                    echo "   Exit code: ${tfxExitCode}"
                    echo "   Output: ${tfxOutput ?: '(empty)'}"
                } else if (hasAuthError) {
                    // Check for authentication error (401) - specific tfx error message format
                    // Only treat as auth error if it matches the exact tfx error message pattern
                    result.message = "Unauthorized (401) ‚Äî Invalid or expired Personal Access Token"
                    echo "‚ùå Azure DevOps Marketplace authentication failed: Invalid or expired PAT"
                    echo "   Error: ${errorMsg.take(200)}"
                } else if (tfxOutput.contains("404") || tfxOutput.contains("Not Found")) {
                    result.message = "Not Found (404) ‚Äî Publisher or extension not found"
                    echo "‚ùå Azure DevOps Marketplace: Publisher or extension not found"
                    echo "   Error: ${errorMsg.take(200)}"
                } else {
                    // Other errors (network, tfx CLI issues, invalid extension ID, etc.) - not authentication related
                    result.message = "Marketplace validation failed (non-authentication error): ${errorMsg.take(100)}"
                    echo "‚ùå Azure DevOps Marketplace validation failed (non-authentication error)"
                    echo "   Exit code: ${tfxExitCode}"
                    echo "   Error: ${errorMsg.take(300)}"
                }
            }
        }
    } catch (Exception e) {
        result.message = handleCredentialError(e, credFileId, pluginName)
    }
    
    return result
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Parses and validates credentials JSON file
 * Returns: [ok: boolean, username: string, password: string, url: string, message: string]
 */
def parseCredentialsFile(String filePath, String pluginName) {
    try {
        def creds = readJSON(text: readFile(file: filePath))
        
        if (!creds.secrets) {
            echo "ERROR: Invalid JSON: missing 'secrets' key"
            return [ok: false, message: "Invalid JSON: missing 'secrets' key"]
        }
        
        def secrets = creds.secrets
        def missingFields = []
        
        if (!secrets.username) missingFields.add('username')
        if (!secrets.password) missingFields.add('password')
        if (!secrets.url) missingFields.add('url')
        
        if (missingFields) {
            echo "ERROR: Missing required fields: ${missingFields.join(', ')}"
            return [ok: false, message: "Missing required fields: ${missingFields.join(', ')}"]
        }
        
        echo "Credentials parsed successfully"
        return [ok: true, username: secrets.username, password: secrets.password, url: secrets.url]
    } catch (Exception e) {
        echo "ERROR: Failed to parse credentials: ${e.message}"
        return [ok: false, message: "Failed to parse JSON: ${e.message}"]
    }
}

/**
 * Handles credential-related errors with helpful troubleshooting info
 */
def handleCredentialError(Exception e, String credFileId, String pluginName) {
    def errorMsg = e.message
    
    echo "ERROR: Credential error:"
    echo "   Message: ${errorMsg}"
    echo "   Credential ID: '${credFileId}'"
    
    def isCredentialNotFound = errorMsg?.toLowerCase()?.contains("not found") || 
                               errorMsg?.contains("CredentialNotFoundException")
    
    if (isCredentialNotFound) {
        echo "   Hint: Create secret file credential with ID '${credFileId}'"
        return "Credentials not configured yet"
    }
    
    return "Error: ${errorMsg?.take(50) ?: 'Unknown error'}"
}

def formatValidationResultsForJenkins(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "Plugin", "Status", "Message", "Timestamp"))
    table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
        "-" * 30, "-" * 10, "-" * 40, "-" * 19))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)
        def message = data.message ?: 'N/A'
        def timestamp = data.timestamp ?: 'N/A'

        table.append(String.format("%-30s | %-10s | %-40s | %-19s\n", 
            displayName, status, message, timestamp))
    }

    table.append("```")
    return table.toString()
}

def formatValidationResultsForSlack(Map results) {
    def table = new StringBuilder("```\n")
    
    table.append(String.format("%-30s | %-10s\n", "Plugin", "Status"))
    table.append(String.format("%-30s | %-10s\n", "-" * 30, "-" * 10))

    results.sort().each { pluginName, data ->
        def displayName = data.displayName ?: pluginName
        def status = getStatusEmoji(data.status)

        table.append(String.format("%-30s | %-10s\n", displayName, status))
    }

    table.append("```")
    return table.toString()
}

def getStatusEmoji(String status) {
    switch(status) {
        case 'SUCCESS': return '‚úÖ'
        case 'FAILURE': return '‚ùå'
        case 'SKIPPED': return '‚è≠Ô∏è'
        default: return status ?: 'N/A'
    }
}

/**
 * Installs JFrog CLI using official installer script
 */
def installJfrogCli() {
    def downloadStatus = sh(
        script: 'curl -fL https://install-cli.jfrog.io | sh',
        returnStatus: true
    )
    
    if (downloadStatus != 0) {
        error "Failed to download JFrog CLI (exit code: ${downloadStatus})"
    }
    
    def verifyStatus = sh(script: 'jf --version', returnStatus: true)
    
    if (verifyStatus != 0) {
        error "Failed to verify JFrog CLI installation (exit code: ${verifyStatus})"
    }
    
    echo "‚úÖ JFrog CLI installed successfully"
}

/**
 * Installs tfx-cli using npm
 * Required for Azure DevOps Marketplace validation
 */
def installTfxCli() {
    // Check if tfx is already installed
    def checkStatus = sh(
        script: 'which tfx || command -v tfx || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (checkStatus != "NOT_FOUND" && checkStatus) {
        echo "‚úÖ tfx-cli is already installed at: ${checkStatus}"
        return
    }
    
    // Check if npm is available, install Node.js/npm if not
    def npmCheck = sh(
        script: 'which npm || command -v npm || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (npmCheck == "NOT_FOUND" || !npmCheck) {
        echo "npm is not installed. Installing Node.js (which includes npm)..."
        installNodeJs()
        
        // Verify npm is now available
        npmCheck = sh(
            script: 'which npm || command -v npm || echo "NOT_FOUND"',
            returnStdout: true
        ).trim()
        
        if (npmCheck == "NOT_FOUND" || !npmCheck) {
            error "Failed to install npm. Node.js installation may have failed."
        }
        
        echo "‚úÖ npm is now available at: ${npmCheck}"
    }
    
    echo "Installing tfx-cli using npm..."
    def installStatus = sh(
        script: 'npm install -g tfx-cli',
        returnStatus: true
    )
    
    if (installStatus != 0) {
        error "Failed to install tfx-cli (exit code: ${installStatus}). Ensure npm is properly configured."
    }
    
    // Verify installation
    def verifyStatus = sh(
        script: 'tfx --version',
        returnStatus: true
    )
    
    if (verifyStatus != 0) {
        error "Failed to verify tfx-cli installation (exit code: ${verifyStatus})"
    }
    
    echo "‚úÖ tfx-cli installed successfully"
}

/**
 * Installs Node.js (which includes npm)
 * Uses NodeSource repository for Ubuntu systems
 */
def installNodeJs() {
    // Check if Node.js is already installed
    def nodeCheck = sh(
        script: 'which node || command -v node || echo "NOT_FOUND"',
        returnStdout: true
    ).trim()
    
    if (nodeCheck != "NOT_FOUND" && nodeCheck) {
        echo "‚úÖ Node.js is already installed at: ${nodeCheck}"
        return
    }
    
    echo "Installing Node.js..."
    
    // Use system package manager directly (safer than curl | bash pattern)
    // This avoids security risks of downloading and executing remote scripts
    def installStatus = sh(
        script: '''
            if apt-get update && apt-get install -y nodejs npm; then
                exit 0
            else
                exit 1
            fi
        ''',
        returnStatus: true
    )
    
    if (installStatus != 0) {
        error "Failed to install Node.js/npm. Please ensure apt package manager is available and has access to nodejs package."
    }
    
    // Verify Node.js installation
    def nodeVerify = sh(
        script: 'node --version',
        returnStatus: true
    )
    
    if (nodeVerify != 0) {
        error "Failed to verify Node.js installation (exit code: ${nodeVerify})"
    }
    
    // Verify npm installation
    def npmVerify = sh(
        script: 'npm --version',
        returnStatus: true
    )
    
    if (npmVerify != 0) {
        error "Failed to verify npm installation (exit code: ${npmVerify})"
    }
    
    def nodeVersion = sh(script: 'node --version', returnStdout: true).trim()
    def npmVersion = sh(script: 'npm --version', returnStdout: true).trim()
    
    echo "‚úÖ Node.js installed successfully (Node.js: ${nodeVersion}, npm: ${npmVersion})"
}

/**
 * Tests Nexus Repository connection using /service/local/status endpoint
 * Returns: [ok: boolean, message: string, username: string, status: int]
 * Uses shell commands to avoid Jenkins sandbox restrictions
 */
def nxPing(String nexusUrl, String username, String password) {
    try {
        def endpoint = "${nexusUrl}/service/local/status"
        
        // Use HEAD request (-I) which is lighter and sufficient for authentication check
        def response = ''
        withEnv([
            "NEXUS_USER=${username}",
            "NEXUS_PASSWORD=${password}",
            "NEXUS_ENDPOINT=${endpoint}"
        ]) {
            response = sh(
                script: '''
                    curl -s -I -w '\\n%{http_code}' \
                    --user "${NEXUS_USER}:${NEXUS_PASSWORD}" \
                    -H 'Accept: application/json' \
                    --connect-timeout 5 \
                    --max-time 10 \
                    "${NEXUS_ENDPOINT}" 2>&1
                ''',
                returnStdout: true
            ).trim()
        }
        
        def lines = response.readLines()
        def statusCode = lines.last() as Integer
        
        // Success - credentials are valid
        if (statusCode == 200 || statusCode == 204) {
            echo "SUCCESS: Nexus Repository connection successful"
            return [ok: true, message: "Credentials valid (${statusCode} OK)", username: username, status: statusCode]
        }
        
        // Authentication failed
        if (statusCode == 401) {
            return [ok: false, message: "Unauthorized (401) ‚Äî Invalid username/password", status: 401]
        }
        
        // Permission denied
        if (statusCode == 403) {
            return [ok: false, message: "Forbidden (403) ‚Äî Valid credentials but insufficient permissions", status: 403]
        }
        
        // Endpoint not supported or other error
        return [ok: false, message: "Endpoint not supported (${statusCode})", status: statusCode]

    } catch (Exception e) {
        return [ok: false, message: "Connection error: ${e.message}", status: -1]
    }
}

/**
 * Parses TeamCity/JetBrains Plugin Repository credentials JSON file
 * Expected format: { "secrets": { "token": "...", "url": "..." } }
 * URL is optional and defaults to https://plugins.jetbrains.com
 * Returns: [ok: boolean, token: string, url: string, message: string]
 */
def parseTeamCityCredentialsFile(String filePath, String pluginName) {
    try {
        def creds = readJSON(text: readFile(file: filePath))
        
        if (!creds.secrets) {
            echo "ERROR: Invalid JSON: missing 'secrets' key"
            return [ok: false, message: "Invalid JSON: missing 'secrets' key"]
        }
        
        def secrets = creds.secrets
        
        if (!secrets.token) {
            echo "ERROR: Missing required field: token"
            return [ok: false, message: "Missing required field: token"]
        }
        
        def url = secrets.url ?: 'https://plugins.jetbrains.com'
        
        echo "Credentials parsed successfully"
        return [ok: true, token: secrets.token, url: url]
    } catch (Exception e) {
        echo "ERROR: Failed to parse credentials: ${e.message}"
        return [ok: false, message: "Failed to parse JSON: ${e.message}"]
    }
}

/**
 * Validates JetBrains Plugin Repository token using the plugin-repository-rest-client library
 * Uses Groovy script with @Grab to load required dependencies
 * Token is passed via environment variable to avoid writing sensitive data to disk
 * Returns: [ok: boolean, message: string, vendorName: string, vendorUrl: string]
 */
def validateJetBrainsPluginRepository(String token, String baseUrl = 'https://plugins.jetbrains.com') {
    // Generate unique filename to avoid conflicts when running parallel validations
    def uniqueId = UUID.randomUUID().toString().take(8)
    def scriptFile = "validate-jetbrains-plugin-repo-${uniqueId}.groovy"
    def output = ''
    
    try {
        // Write the validation script to a temporary file
        // Script reads token from environment variable to avoid writing sensitive data to disk
        // Escape double quotes and backslashes for use in double-quoted string
        def escapedBaseUrl = baseUrl.replace('\\', '\\\\').replace('"', '\\"')
        
        def scriptContent = """#!/usr/bin/env groovy

@Grab('org.jetbrains.intellij:plugin-repository-rest-client:2.0.50')
@Grab('org.slf4j:slf4j-simple:2.0.16')

import org.jetbrains.intellij.pluginRepository.PluginRepository
import org.jetbrains.intellij.pluginRepository.PluginRepositoryException
import org.jetbrains.intellij.pluginRepository.PluginRepositoryFactory
import org.jetbrains.intellij.pluginRepository.model.PluginVendorBean

String pluginUrl = "${escapedBaseUrl}"
String pluginToken = System.getenv('JETBRAINS_PLUGIN_TOKEN')

if (pluginToken == null || pluginToken.trim().isEmpty()) {
    throw new IllegalArgumentException('Missing JETBRAINS_PLUGIN_TOKEN environment variable')
}

try {
    PluginRepository repository = PluginRepositoryFactory.create(pluginUrl, pluginToken)
    PluginVendorBean vendor = repository.getVendorManager().getVendorOfCurrentUser()
    if (vendor == null) {
        throw new PluginRepositoryException('Authenticated but no vendor is associated with this token')
    }
    String vendorName = vendor.getPublicName() ?: vendor.getName()
    String vendorUrl = vendor.getUrl() ?: 'N/A'
    println "SUCCESS|VENDOR_NAME:\${vendorName}|VENDOR_URL:\${vendorUrl}"
} catch (PluginRepositoryException ex) {
    println "FAILURE|ERROR:\${ex.message}"
    System.exit(1)
} catch (Exception ex) {
    println "FAILURE|ERROR:\${ex.message}"
    System.exit(1)
}
"""
        
        writeFile(file: scriptFile, text: scriptContent)
        
        // Set restrictive permissions on the script file (read/write for owner only)
        sh("chmod 600 ${scriptFile} || true")
        
        // Execute the Groovy script with token passed via environment variable
        // The token is already masked by MaskPasswordsBuildWrapper in the calling function
        withEnv([
            "JETBRAINS_PLUGIN_TOKEN=${token}",
            "JETBRAINS_PLUGIN_URL=${baseUrl}"
        ]) {
            output = sh(
                script: "groovy ${scriptFile} 2>&1 || true",
                returnStdout: true
            ).trim()
        }
        
        // Clean up the script file securely
        sh("rm -f ${scriptFile} || true")
        
        if (output.contains('SUCCESS|')) {
            def parts = output.split('\\|')
            def vendorName = ''
            def vendorUrl = ''
            
            parts.each { part ->
                if (part.startsWith('VENDOR_NAME:')) {
                    vendorName = part.substring('VENDOR_NAME:'.length())
                } else if (part.startsWith('VENDOR_URL:')) {
                    vendorUrl = part.substring('VENDOR_URL:'.length())
                }
            }
            
            def message = "Credentials valid"
            if (vendorName && vendorName != 'N/A') {
                message += " ‚Äî Vendor: ${vendorName}"
            }
            if (vendorUrl && vendorUrl != 'N/A') {
                message += " (${vendorUrl})"
            }
            
            return [ok: true, message: message, vendorName: vendorName, vendorUrl: vendorUrl]
        } else if (output.contains('FAILURE|')) {
            def parts = output.split('\\|')
            def errorMsg = 'Unknown error'
            
            parts.each { part ->
                if (part.startsWith('ERROR:')) {
                    errorMsg = part.substring('ERROR:'.length())
                }
            }
            
            return [ok: false, message: "JetBrains credentials invalid or repository unreachable: ${errorMsg}"]
        } else {
            return [ok: false, message: "Unexpected output from validation script: ${output.take(200)}"]
        }
        
    } catch (Exception e) {
        // Clean up script file on error
        sh("rm -f ${scriptFile} || true")
        
        def errorMsg = e.message ?: 'Unknown error'
        if (errorMsg.contains('No such file or directory') || errorMsg.contains('command not found')) {
            return [ok: false, message: "Groovy not available or @Grab dependencies failed to load: ${errorMsg}"]
        }
        return [ok: false, message: "Connection error: ${errorMsg}"]
    }
}
