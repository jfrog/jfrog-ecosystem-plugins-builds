// Jenkins CI pipeline for validating JFrog Artifactory credentials across multiple ecosystem plugins.
// Runs nightly to ensure credentials are properly configured and functional.
// Notifies Slack with validation results in markdown table format.

node("docker-ubuntu20-xlarge") {
    properties([
        parameters([
            string(
                name: 'SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION',
                defaultValue: 'jfrog-ecosystem-plugins-notifications',
                description: 'Slack channel for credential validation notifications'
            ),
            choice(
                name: 'PLUGIN_TO_VALIDATE',
                choices: ['ALL', 'jenkins-jfrog-plugin', 'bamboo-jfrog-plugin', 'teamcity-jfrog-plugin', 'azure-devops-extension'],
                description: 'Select specific plugin to validate or ALL for all plugins'
            )
        ]),
        pipelineTriggers([
            cron('0 1 * * *')  // Run at 1 AM daily
        ])
    ])
    
    try {
        validationResults = [:]
        buildStatus = 'SUCCESS'
        cliExecutableName = 'jf'
        formattedDate = new Date().format('yyyy-MM-dd HH:mm:ss')
        env.JFROG_CLI_LOG_LEVEL = "ERROR"  // Minimize logging for security
        slackChannelName = params.SLACK_CHANNEL_FOR_PLUGINS_DEV_BUILD_NOTIFICATION
        pluginToValidate = params.PLUGIN_TO_VALIDATE
        
        // Define plugin credential mapping
        // Each plugin uses a secret file credential containing JSON with username, password, and URL
        def pluginsMap = [
            "jenkins-jfrog-plugin": [
                credFileId: "jenkins-jfrog-creds",
                active: true,
                displayName: "Jenkins JFrog Plugin"
            ],
            "bamboo-jfrog-plugin": [
                credFileId: "bamboo-plugin-creds-json",
                active: false,
                displayName: "Bamboo JFrog Plugin"
            ],
            "teamcity-jfrog-plugin": [
                credFileId: "teamcity-plugin-creds-json",
                active: false,
                displayName: "TeamCity JFrog Plugin"
            ],
            "azure-devops-extension": [
                credFileId: "azure-devops-plugin-creds-json",
                active: false,
                displayName: "Azure DevOps Extension"
            ]
        ]
        
        dir('credential-validation-temp') {
            stage('Initial Setup') {
                try {
                    script {
                        installJfrogCli()
                        echo "JFrog CLI installed successfully"
                    }
                } catch (e) {
                    echo "Error during initial setup: ${e}"
                    throw e
                }
            }
            
            script {
                def tasksToRun = createValidationTasks(pluginsMap, pluginToValidate)
                parallel(tasksToRun)
            }
        }
    } catch (e) {
        echo "ERROR: Pipeline failed with exception: ${e}"
        buildStatus = 'FAILURE'
        throw e
    } finally {
        stage('Send Notifications') {
            sendSlackNotification(validationResults, buildStatus, slackChannelName, formattedDate)
        }
    }
}

def sendSlackNotification(Map validationResults, String buildStatus, String channelName, String timestamp) {
    def statusCounts = calculateStatusCounts(validationResults)
    def markdownTable = formatValidationResults(validationResults)
    def notificationConfig = determineNotificationConfig(buildStatus, statusCounts)
    
    def message = buildSlackMessage(notificationConfig, statusCounts, timestamp, markdownTable)
    
    slackSend(
        channel: "#${channelName}",
        message: message,
        color: notificationConfig.color
    )
    
    echo "Final notification message:\n${message}"
}

def calculateStatusCounts(Map validationResults) {
    return [
        success: validationResults.count { k, v -> v.status == 'SUCCESS' },
        failure: validationResults.count { k, v -> v.status == 'FAILURE' },
        skipped: validationResults.count { k, v -> v.status == 'SKIPPED' }
    ]
}

def determineNotificationConfig(String buildStatus, Map statusCounts) {
    if (buildStatus != 'SUCCESS') {
        return [
            icon: '❌',
            title: 'Credential Validation Pipeline Failed',
            color: 'danger',
            mentionChannel: true
        ]
    }
    
    if (statusCounts.failure > 0) {
        return [
            icon: '⚠️',
            title: 'Credential Validation Results',
            color: 'warning',
            mentionChannel: false
        ]
    }
    
    return [
        icon: '✅',
        title: 'Credential Validation Results',
        color: 'good',
        mentionChannel: false
    ]
}

def buildSlackMessage(Map config, Map statusCounts, String timestamp, String markdownTable) {
    def messageBuilder = new StringBuilder()
    
    if (config.mentionChannel) {
        messageBuilder.append('@here ')
    }
    
    messageBuilder.append("*${config.title}* ${config.icon}\n")
    messageBuilder.append("*Date:* ${timestamp}\n")
    
    if (statusCounts.success > 0 || statusCounts.failure > 0 || statusCounts.skipped > 0) {
        messageBuilder.append("*Status:* ")
        def statusParts = []
        
        if (statusCounts.success > 0) {
            statusParts.add("✅ ${statusCounts.success} Successful")
        }
        if (statusCounts.failure > 0) {
            statusParts.add("❌ ${statusCounts.failure} Failed")
        }
        if (statusCounts.skipped > 0) {
            statusParts.add("⏭️ ${statusCounts.skipped} Skipped")
        }
        
        messageBuilder.append(statusParts.join(', '))
        messageBuilder.append('\n')
    }
    
    messageBuilder.append("<${env.BUILD_URL}|View Build>\n\n")
    messageBuilder.append(markdownTable)
    
    return messageBuilder.toString()
}

def createValidationTasks(Map pluginsMap, String pluginToValidate) {
    def tasks = [:]
    
    pluginsMap.each { pluginName, details ->
        // Filter based on user selection
        if (pluginToValidate == "ALL" || pluginToValidate == pluginName) {
            tasks[pluginName] = {
                validationResults[pluginName] = [
                    status: 'PENDING',
                    message: '',
                    timestamp: '',
                    displayName: details.displayName
                ]
                validatePluginCredentials(pluginName, details)
            }
        }
    }
    
    return tasks
}

def validatePluginCredentials(String pluginName, Map details) {
    def credFileId = details.credFileId
    def isActive = details.active
    def startTime = new Date().format('yyyy-MM-dd HH:mm:ss')
    
    stage("Validate ${details.displayName}") {
        if (!isActive) {
            echo "Skipping ${pluginName} - validation is not active"
            validationResults[pluginName].status = 'SKIPPED'
            validationResults[pluginName].message = 'Validation not active yet'
            validationResults[pluginName].timestamp = startTime
            return
        }
        
        echo "Starting validation for ${pluginName}..."
        def result = testJFrogConnection(credFileId, pluginName)
        
        validationResults[pluginName].status = result.status
        validationResults[pluginName].message = result.message
        validationResults[pluginName].timestamp = startTime
        
        echo "Validation completed for ${pluginName}: ${result.status}"
    }
}

def testJFrogConnection(String credFileId, String pluginName) {
    def tempConfigName = "temp-${pluginName}-${UUID.randomUUID().toString().substring(0, 8)}"
    def result = [status: 'FAILURE', message: '']
    
    try {
        try {
            withCredentials([file(credentialsId: credFileId, variable: 'CREDS_FILE')]) {
                echo "Credentials file found for ${pluginName}, parsing JSON..."
                
                // Read and parse JSON file
                def credsJson = readFile(file: env.CREDS_FILE)
                def creds = readJSON(text: credsJson)
                
                // Validate JSON structure
                if (!creds.secrets) {
                    result.message = "Invalid JSON structure: missing 'secrets' key"
                    echo "❌ Invalid JSON format for ${pluginName}"
                    return result
                }
                
                def username = creds.secrets.username
                def password = creds.secrets.password
                def url = creds.secrets.url
                
                // Validate required fields
                if (!username || !password || !url) {
                    result.message = "Invalid JSON: missing required fields (username, password, or url)"
                    echo "❌ Missing required fields in JSON for ${pluginName}"
                    echo "   username: ${username ? 'present' : 'MISSING'}"
                    echo "   password: ${password ? 'present' : 'MISSING'}"
                    echo "   url: ${url ? 'present' : 'MISSING'}"
                    return result
                }
                
                echo "✅ Credentials parsed successfully, testing connection..."
                
                // Configure JFrog CLI with temporary config
                def configResult = sh(
                    script: "jf c add ${tempConfigName} --url='${url}' --user='${username}' --password='${password}' --overwrite",
                    returnStatus: true
                )
                
                if (configResult != 0) {
                    result.message = "Failed to configure JFrog CLI - check URL format and credentials"
                    echo "❌ JFrog CLI configuration failed for ${pluginName}"
                    return result
                }
                
                // Use the temporary config
                sh "jf c use ${tempConfigName}"
                
                // Test connection with ping
                def pingResult = sh(
                    script: "jf rt ping",
                    returnStatus: true
                )
                
                if (pingResult == 0) {
                    result.status = 'SUCCESS'
                    result.message = 'Connection successful'
                    echo "✅ Connection test passed for ${pluginName}"
                } else {
                    result.message = 'Connection failed - unable to ping JFrog instance'
                    echo "❌ Connection test failed for ${pluginName}"
                }
            }
        } catch (Exception credEx) {
            def credentialsError = credEx.message
            
            echo "❌ Full error details for ${pluginName}:"
            echo "   Error message: ${credentialsError}"
            echo "   Looking for secret file credential ID: '${credFileId}'"
            echo "   Error type: ${credEx.getClass().getName()}"
            
            // Check if it's a missing credentials error
            if (credentialsError.contains("Could not find credentials") || 
                credentialsError.contains("CredentialNotFoundException") ||
                credentialsError.contains("No credentials found") ||
                credentialsError.contains("cannot find") ||
                credentialsError.toLowerCase().contains("not found")) {
                result.message = "Credentials not configured yet. Create a secret file credential with ID '${credFileId}'"
                echo "❌ Credentials not found for ${pluginName}"
                echo "   Troubleshooting:"
                echo "   - Create a secret file credential with ID '${credFileId}'"
                echo "   - Ensure JSON format: {\"secrets\": {\"username\": \"...\", \"password\": \"...\", \"url\": \"...\"}}"
                echo "   - Verify this job has permission to access the credentials"
            } else {
                result.message = "Error accessing credentials: ${credentialsError}"
                echo "❌ Error accessing credentials for ${pluginName}: ${credentialsError}"
            }
        }
    } catch (Exception e) {
        result.message = "Unexpected error: ${e.message}"
        echo "❌ Unexpected error during validation of ${pluginName}: ${e.message}"
    } finally {
        // Always cleanup the temporary config
        try {
            sh "jf c rm ${tempConfigName} --quiet || true"
        } catch (Exception cleanupEx) {
            echo "Warning: Could not cleanup temp config ${tempConfigName}: ${cleanupEx.message}"
        }
    }
    
    return result
}

def formatValidationResults(Map results) {
    def message = new StringBuilder("```\n")
    
    message.append(String.format("%-30s | %-10s | %-35s | %-19s\n", "Plugin", "Status", "Message", "Timestamp"))
    message.append(String.format("%-30s | %-10s | %-35s | %-19s\n", "------------------------------", "----------", "-----------------------------------", "-------------------"))
    
    results.sort().each { pluginName, data ->
        def status = data.status ?: 'PENDING'
        def displayName = data.displayName ?: pluginName
        def msg = data.message ?: 'N/A'
        def timestamp = data.timestamp ?: 'N/A'
        
        // Add emoji to status like dev-build does
        def statusWithEmoji = status
        switch(status) {
            case 'SUCCESS':
                statusWithEmoji = '✅'
                break
            case 'FAILURE':
                statusWithEmoji = '❌'
                break
            case 'SKIPPED':
                statusWithEmoji = '⏭️'
                break
            default:
                statusWithEmoji = 'PENDING'
        }
        
        message.append(String.format("%-30s | %-10s | %-35s | %-19s\n", displayName, statusWithEmoji, msg, timestamp))
    }
    
    message.append("```")
    return message.toString()
}

// Install JFrog CLI if not already installed on the system using the curl command
// Check if JFrog CLI is installed by running the jf --version command
def installJfrogCli() {
    def curlStatus = sh(script: 'curl -fL https://install-cli.jfrog.io | sh', returnStatus: true)
    if (curlStatus != 0) {
        error "Failed to download JFrog CLI. Exit code: ${curlStatus}"
    }
    
    def versionStatus = sh(script: 'jf --version', returnStatus: true)
    if (versionStatus != 0) {
        error "Failed to verify JFrog CLI installation. Exit code: ${versionStatus}"
    }
    
    echo "JFrog CLI installed successfully"
}

